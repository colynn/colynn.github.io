<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Colynn.Liu"><link rel=prev href=https://colynn.github.io/2020-03-29-golang-101/><link rel=next href=https://colynn.github.io/2020-04-10-kubernetes-networking-flannel-calico/><link rel=canonical href=https://colynn.github.io/2020-04-02-vxlan-is-what/><link rel=apple-touch-icon sizes=180x180 href=/img/home-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>VXLAN是什么及如何在容器间通信 | Colynn.Liu</title><meta name=title content="VXLAN是什么及如何在容器间通信 | Colynn.Liu"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/colynn.github.io\/"},"articleSection":"posts","name":"VXLAN是什么及如何在容器间通信","headline":"VXLAN是什么及如何在容器间通信","description":"引言 服务器虚拟化基于物理网络基础设施提出了更高的要求，一个物理服务器多个VMs并且每一个vm归有一个自己的Meida Access Control(MAC","inLanguage":"zh-CN","author":"Colynn.Liu","creator":"Colynn.Liu","publisher":"Colynn.Liu","accountablePerson":"Colynn.Liu","copyrightHolder":"Colynn.Liu","copyrightYear":"2020","datePublished":"2020-04-02 00:00:00 \u002b0000 UTC","dateModified":"2020-04-02 00:00:00 \u002b0000 UTC","url":"https:\/\/colynn.github.io\/2020-04-02-vxlan-is-what\/","wordCount":"2498","keywords":["运维","flannel","Colynn.Liu"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://colynn.github.io/>Colynn.Liu</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://colynn.github.io/>Colynn.Liu</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">VXLAN是什么及如何在容器间通信</h1><div class=post-meta>Written by <a itemprop=name href=https://colynn.github.io/ rel=author>Colynn.Liu</a> with ♥
<span class=post-time>on <time datetime=2020-04-02 itemprop=datePublished>April 2, 2020</time></span>
<span class=post-time>- last modified <time datetime=2020-04-02 itemprop=datePublished>April 2, 2020</time></span></div><div class=post-tags><section><span class=tag><a href=https://colynn.github.io/tags/%E8%BF%90%E7%BB%B4/><i class="iconfont icon-tag"></i>运维</a></span>
<span class=tag><a href=https://colynn.github.io/tags/flannel/><i class="iconfont icon-tag"></i>flannel</a></span></section><section><i class="iconfont icon-folder"></i><span class=post-category><a href=https://colynn.github.io/categories/%E6%95%99%E7%A8%8B/>教程</a></span></section></div></header><div class=post-content><h2 id=引言>引言</h2><ul><li><p>服务器虚拟化基于物理网络基础设施提出了更高的要求，一个物理服务器多个VMs并且每一个vm归有一个自己的Meida Access Control(MAC)地址. 在交换式以太网中为了应对在成百上千的VMs中可能存在的通信连接， 需要较大的MAC地址表。</p></li><li><p>在数据中心根据vlan来对VMs分组的话，可能需要上千个VLANs, 但是当前VLAN个数的限制是4094，不能满足这个场景。</p></li><li><p>数据中心通过需要托管多个租户，而且他们之间是独立的网络区域，如果基于专用的基础设施显然是很不经济的，所以网络工程师选择基于共享的网络实现隔离。在这种场景下，一个常用的问题就是每个租户独立地分配MAC和VLAN IDs, 导致物理网络上的这些信息可能会重复。</p></li><li><p>对于使用2层物理基础设施的虚拟化环境，一个重要的要求是要在整个数据中心甚至是数据中心之间进行第2层网络的扩展，以便有效地分配计算、网络和存储资源。 在这样的网络中，使用传统的方法，如Spanning Tree Protocol (STP)来实现无环路拓扑结构，会导致大量的失效链路。</p></li><li><p>最后一种情况是，网络运营商更倾向于利用IP进行物理基础设施的互联互通通过等成本多路径（ECMP）实现多路径可扩展性, 从而避免了失效的链接）。即使在这种环境下，也有需要保留第2层模型，以实现VM间通信。</p></li></ul><p>上面描述的场景导致了对overly network的要求，该overlay用于通过逻辑“隧道”以封装的格式承载来自各个VM的MAC二层流量。 也是『Virtual eXtensible Local Area Network（VXLAN）』。</p><p>概述：VXLAN是一种VLAN扩展技术，它将标准的第2层以太网帧封装在IP内，特别是使用互联网编号分配机构(IANA)分配的UDP端口4789封装中的此MAC地址创建了一个隧道，允许您将第2层网段扩展到任何第3层网络。</p><p>虚拟可扩展局域网(VXLAN)是一种试图解决与大型云计算部署相关的可扩展性问题的网络虚拟化技术。</p><p><strong>注:</strong> VXLAN is a Layer 2 overlay scheme on a Layer 3 network.</p><h2 id=vxlan是如何工作的>VXLAN是如何工作的？</h2><p>我们已经知道VXLAN是在3层网络之上创建虚拟的2层网络，但是具体是工作的呢？我们知道在传统的VLAN模式下，通过网段内的ARP广播及网关（同网段不需要网关），从而可以将数据包传送到目标地址。</p><p>同样，VXLAN也存在这样的问题，但想让数据包在3层之上为2层封装显然是不可以的，从而就是在VXLAN的端口（也就是<code>VTEP</code>）提供如下功能：</p><ol><li>ARP 解决方案: 需要响应来自本地服务器的ARP请求而不广播ARP数据包。</li><li>目标搜索：需要找到与目标MAC对应的目的地位置。</li></ol><p><img src=https://user-images.githubusercontent.com/5203608/89412787-3ab21800-d75a-11ea-8c5a-0c81c4df1f4b.png alt=image></p><p>为了实现<code>VTEP</code>的功能，必须有一些机制可以共享服务器的MAC、IP地址、位置, 基于云原生的时代，下面作者就使用Flannel看下VTEP是如何实现的。</p><p>Flannel是为一个为容器创建overlay网络的开源工具，经常和kubernetes一起使用。</p><ul><li>使用Linux内核原生的VXLAN设备用于数据包的封装；</li><li>Flannel守护进程<code>flanneld</code>根据内核请求，通过 &ldquo;L2/L3 MISS &ldquo;通知机制，动态填充FDB和ARP表。<ul><li>这种机制原本的名字是『DOVER extensions』<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e4f67addf158f98f8197e08974966b18480dc751">kernerl commits - add DOVE extensions for VXLAN</a></li></ul></li><li>通过<code>etcd</code>来共享 IP/MAC 信息。</li></ul><h2 id=跨主机容器通信>跨主机容器通信</h2><p>基于一个例子更好地理解VXLAN是怎样工作的。</p><p><img src=https://user-images.githubusercontent.com/5203608/89412792-3ede3580-d75a-11ea-98a5-ba2d355ff690.png alt=image></p><p><strong>注</strong>: 可以网络结构中看到，<code>VTEP</code>在容器外部。这意味着容器不知道隧道的存在。 这就是VXLAN能够使容器误以为它们已连接到同一网段的原因。</p><p>如上图所示， 假设Node1的container-1需要与Node2的container-3通信， 我们一起看下数据包是如何传输的。</p><p>首先，容器container-1通过虚拟以太网接口(<code>VETP</code>)类型的接口veth0将数据包(如下图)传送给网桥<code>docker0</code>。 连接着网桥的另一个端点就是<code>flannel0</code>,</p><p><em>注</em>: Flannel不控制容器如何与主机通信，而仅控制主机之间的流量传输方式。也就是如果网络头目标IP地址用于VXLAN之外的主机，则将帧发送到物理网络接口，flannel不会做任何处理。但是如何确定目标IP是VXLAN之内或是VXLAN之外，可能还要继续研究flannel相关代码才能了解。</p><p><img src=https://user-images.githubusercontent.com/5203608/89412922-777e0f00-d75a-11ea-9878-0b3f445d7efe.png alt=image></p><p>可能你会疑问，为什么container-1知识container-3的MAC地址，这是通过标准ARP报文完成的，只是ARP报文将通过VTEP隧道化传输。因为在每个主机上，flannel运行一个守护进程（<code>flanneld</code>）, flannel守护进程<code>flanneld</code>会根据内核请求，通过 <a href="(https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e4f67addf158f98f8197e08974966b18480dc751)">&ldquo;L2/L3 MISS &ldquo;通知机制</a>，动态填充FDB和ARP表, 并且将IP/MAC信息通过<code>etcd</code>存储起来。</p><p>当<code>flanneld</code>看到来自容器的ARP报文时，它将把它发送到VXLAN多播组，这样所有参与VXLAN的VTEP都会看到这个ARP。底层不会看到这个ARP报文，因为它被隧道化了。因此，底层的硬件不会广播任何ARP报文。</p><p><code>flanneld</code>与<code>flannel0</code>与<code>eth0</code>共同构成了VTEP的管道， <code>VTEP</code>是另一种称为虚拟隧道端点的Linux网络结构, 它是VXLAN隧道的入口/出口点。容器中的数据包将在这里使用Linux内核原生的VXLAN设备完成数据包的封装， 添加了VXLAN部分:</p><p><img src=https://user-images.githubusercontent.com/5203608/89412993-97adce00-d75a-11ea-93ff-10d1c27fd508.png alt=image></p><p>首先，我们看到包含VXLAN头和UDP头的传输头。 接下来是外部（VXLAN）网络头。 在这里，我们看到源IP地址和目标IP地址分别是Node1和Node2的<code>eth0</code>。</p><p>因Node1/Node2均在同一网段，可以直接找到Node2接点（如果Node1与Node2不在同一网段，则会外部VXLAN网络头在不同的网络之间路由，当然这个时候源及目标MAC也就不是Node1与Node2, 因为通过不同的网络进行路由时，源及目标MAC会发生变化）。 数据包到达Node2，该过程就被逆转。 VXLAN帧将进入<code>flanneld</code>并被解封装，然后原始帧将通过veth1从网桥移动到container-3。</p><h2 id=写在最后>写在最后</h2><p>关于 VXLAN 的最后一点，因为帧的封装/去封装会增加网络堆栈的开销，硬件加速可以减少开销但无法消除。使用诸如<a href=https://projectcalico.org><code>Calico</code></a>之类的解决方案可以避免这种开销。</p><h2 id=参考>参考</h2><ol><li><a href=https://tools.ietf.org/html/rfc7348#section-3.3>RFC7348- Virtual eXtensible Local Area Network (VXLAN)</a></li><li><a href=https://www.slideshare.net/enakai/how-vxlan-works-on-linux>How vxlan works on linux</a></li><li><a href=https://community.arm.com/developer/tools-software/tools/b/tools-software-ides-blog/posts/understanding-and-deploying-overlay-networks>Understanding Overlay Networks In Cloud Deployments</a></li></ol></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Colynn.Liu</span></p><p class=copyright-item><span>Link:</span>
<a href=https://colynn.github.io/2020-04-02-vxlan-is-what/>https://colynn.github.io/2020-04-02-vxlan-is-what/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://colynn.github.io/tags/%E8%BF%90%E7%BB%B4/>#运维</a></span>
<span class=tag><a href=https://colynn.github.io/tags/flannel/>#flannel</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://colynn.github.io/>home</a></span></section></div><div class=post-nav><a href=https://colynn.github.io/2020-03-29-golang-101/ class=prev rel=prev title="如何让你的Go代码更规范 - 辅助工具/项目结构/代码规范"><i class="iconfont icon-left"></i>&nbsp;如何让你的Go代码更规范 - 辅助工具/项目结构/代码规范</a>
<a href=https://colynn.github.io/2020-04-10-kubernetes-networking-flannel-calico/ class=next rel=next title=kubernetes-网络组件-flannel-calico>kubernetes-网络组件-flannel-calico&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><script src=https://utteranc.es/client.js repo=colynn/blog-comments issue-term=pathname label=utterances theme=github-light crossorigin=anonymous async></script></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2018 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://colynn.github.io/>Colynn.Liu</a> |</span>
<span><a href=https://colynn.github.io/friends>友情链接</a></span></div></footer><link href=//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css rel=stylesheet><script src=/js/vendor_gallery.min.js async></script></div></body></html>