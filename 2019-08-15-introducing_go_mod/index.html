<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Colynn.Liu"><meta name=description content="Full-Stack DevOps, Be focused and Practical"><link rel=prev href=https://colynn.github.io/2019-07-26-basic_knowledge_summarizing/><link rel=next href=https://colynn.github.io/2019-09-15-kubespray-deploy-k8s/><link rel=canonical href=https://colynn.github.io/2019-08-15-introducing_go_mod/><link rel=apple-touch-icon sizes=180x180 href=/img/home-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Go Mod 包管理 & 常见问题 | Colynn.Liu</title><meta name=title content="Go Mod 包管理 & 常见问题 | Colynn.Liu"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/colynn.github.io\/"},"articleSection":"posts","name":"Go Mod 包管理 \u0026 常见问题","headline":"Go Mod 包管理 \u0026 常见问题","description":"前言 In Go 1.11, a new tool has arrived. It\u0026rsquo;s called go mod. For those who don\u0026rsquo;t know what is that, I\u0026rsquo;ll tell you about it. One of the purposes of this tool is to get rid of $GOPATH, so you can git clone a Golang repository anywhere and work on it without worrying about $GOPATH at all. There are other purposes of course, such as simpler versioning and","inLanguage":"zh-CN","author":"Colynn.Liu","creator":"Colynn.Liu","publisher":"Colynn.Liu","accountablePerson":"Colynn.Liu","copyrightHolder":"Colynn.Liu","copyrightYear":"2019","datePublished":"2019-08-15 00:00:00 \u002b0000 UTC","dateModified":"2019-08-15 00:00:00 \u002b0000 UTC","url":"https:\/\/colynn.github.io\/2019-08-15-introducing_go_mod\/","wordCount":"2356","keywords":["go","go mod","Colynn.Liu"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/readings/>书单</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/readings/>书单</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">Go Mod 包管理 & 常见问题</h1><div class=post-meta>Written by <a itemprop=name href=https://colynn.github.io/ rel=author>Colynn.Liu</a> with ♥
<span class=post-time>on <time datetime=2019-08-15 itemprop=datePublished>August 15, 2019</time></span>
<span class=post-time>- last modified on <time datetime=2019-08-15 itemprop=datePublished>September 25, 2020</time></span></div><div class=post-tags><section><span class=tag><a href=https://colynn.github.io/tags/go/><i class="iconfont icon-tag"></i>go</a></span>
<span class=tag><a href=https://colynn.github.io/tags/go-mod/><i class="iconfont icon-tag"></i>go mod</a></span></section><section></section></div></header><div class=post-content><h2 id=前言>前言</h2><p>In Go 1.11, a new tool has arrived. It&rsquo;s called go mod. For those who don&rsquo;t know what is that, I&rsquo;ll tell you about it.</p><p>One of the purposes of this tool is to get rid of <code>$GOPATH</code>, so you can git clone a Golang repository anywhere and work on it without worrying about $GOPATH at all. There are other purposes of course, such as simpler versioning and usage, but I think the RIP <code>$GOPATH</code> is the most notable.</p><p>If the repository is a mod, all the tools you use regularly (<code>go get</code>, <code>go build</code>, etc.) will handle it nicely without changing anything.</p><h2 id=如何使用-modules>如何使用 Modules</h2><p>把 golang 升级到 1.11（<del>现在1.12 已经发布了，建议使用1.12</del>）</p><p>设置 GO111MODULE</p><p><code>go mod init [module-name]</code>. Yep, that&rsquo;s all you have to do. If you&rsquo;re trying to go mod-ify an existing project that uses $GOPATH, you should export the <code>GO111MODULE=on</code> variable (<code>go mod</code> will tell you that as well).</p><h2 id=go111module>GO111MODULE</h2><p>GO111MODULE 有三个值：off, on和auto（默认值）。</p><ul><li>GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。</li><li>GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。</li><li>GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：<ul><li>当前目录在GOPATH/src之外且该目录包含go.mod文件</li><li>当前文件在包含go.mod文件的目录下面。</li></ul></li></ul><p><strong>注</strong>: 当modules 功能启用时，依赖包的存放位置变更为$GOPATH/pkg/mod，允许同一个package多个版本并存，且多个项目可以共享缓存的 module。</p><h2 id=how-it-work>How it work</h2><p>再你初始化 go mod 后，如何让你的项目依赖一下第三方包，以大部分人都熟悉的beego为例吧！
修改Hello.go文件：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> <span style=background-color:#fff0f0>&#34;github.com/astaxie/beego&#34;</span>

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
    beego.<span style=color:#06b;font-weight:700>Run</span>()
}
</code></pre></div><h3 id=1之前做法>1.之前做法</h3><p>要运行hello.go需要执行go get 命令 下载beego包到 <code>$GOPATH/src</code></p><h3 id=2当前推荐做法>2.当前推荐做法</h3><p>直接 <code>go run hello.go</code></p><p>稍等片刻… go 会自动查找代码中的包，下载依赖包，并且把具体的依赖关系和版本写入到go.mod和go.sum文件中。
查看go.mod，它会变成这样：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>module hello

<span style=color:#080;font-weight:700>go</span> <span style=color:#60e;font-weight:700>1.12</span>

require github.com<span style=color:#333>/</span>astaxie<span style=color:#333>/</span>beego v1<span style=color:#60e;font-weight:700>.11.1</span>
</code></pre></div><h3 id=3-gomod文件解释>3. go.mod文件解释</h3><p>require 关键子是引用，后面是包，最后v1.11.1 是引用的版本号； 这样，一个使用Go包管理方式创建项目的小例子就完成了。</p><h2 id=问题一-依赖包的版本是怎么控制的>问题一： 依赖包的版本是怎么控制的？</h2><p>下载的依赖包 （<code>$GOPATH/pkg/mod</code>）是存在版本定义的（如：github.com/astaxie/beego@v1.11.1 ）最后会有一个版本号 1.11.1，也就是说，<code>$GOPATH/pkg/mod</code>里可以保存相同包的不同版本。</p><p>版本是在go.mod中指定的:</p><ul><li><p>如果，在go.mod中没有指定，go命令会自动下载代码中的依赖的最新版本，本例就是自动下载最新的版本。</p></li><li><p>如果，在go.mod用require语句指定包和版本 ，go命令会根据指定的路径和版本下载包，
指定版本时可以用latest，这样它会自动下载指定包的最新版本；</p></li></ul><h3 id=依赖包的版本号是什么>依赖包的版本号是什么？</h3><p>是包的发布者标记的版本号，格式为 vn.n.n (n代表数字)，本例中的beego的历史版本可以在其代码仓库release看到Releases · astaxie/beego · GitHub</p><p>如果包的作者还没有标记版本，默认为 v0.0.0</p><h2 id=问题二-依赖包中的地址失效了怎么办>问题二： 依赖包中的地址失效了怎么办？</h2><p>比如 golang.org/x/… 下的包都无法下载怎么办？
在go快速发展的过程中，有一些依赖包地址变更了。
以前的做法</p><p>修改源码，用新路径替换import的地址
git clone 或 go get 新包后，copy到$GOPATH/src里旧的路径下
无论什么方法，都不便于维护，特别是多人协同开发时。</p><p>使用go.mod就简单了，在go.mod文件里用 replace 替换包，例如</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>replace golang.org<span style=color:#333>/</span>x<span style=color:#333>/</span>text =&gt; github.com<span style=color:#333>/</span>golang<span style=color:#333>/</span>text latest
</code></pre></div><p>这样，go会用 <code>github.com/golang/text</code> 替代<code>golang.org/x/text</code>，原理就是下载<code>github.com/golang/text</code> 的最新版本到 <code>$GOPATH/pkg/mod/golang.org/x/text</code>下。</p><h2 id=问题三-init生成的gomod的模块名称有什么用>问题三： init生成的go.mod的模块名称有什么用？</h2><p>本例里，用 go mod init hello 生成的go.mod文件里的第一行会申明
module hello</p><p>因为我们的项目已经不在$GOPATH/src里了，那么引用自己怎么办？就用模块名+路径。</p><p>例如，在项目下新建目录 utils，创建一个tools.go文件:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> utils

<span style=color:#080;font-weight:700>import</span> <span style=color:red;background-color:#faa>“</span>fmt<span style=color:red;background-color:#faa>”</span>

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>PrintText</span>(text <span style=color:#339;font-weight:700>string</span>) {
    fmt.<span style=color:#06b;font-weight:700>Println</span>(text)
}
</code></pre></div><p>在根目录下的hello.go文件就可以 import “hello/utils” 引用utils</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> (
<span style=background-color:#fff0f0>&#34;hello/utils&#34;</span>

<span style=background-color:#fff0f0>&#34;github.com/astaxie/beego&#34;</span>
)

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {

    utils.<span style=color:#06b;font-weight:700>PrintText</span>(<span style=background-color:#fff0f0>&#34;Hi&#34;</span>)

    beego.<span style=color:#06b;font-weight:700>Run</span>()
}
</code></pre></div><h2 id=问题四以前老项目如何用新的包管理>问题四：以前老项目如何用新的包管理</h2><ol><li>如果用<code>auto</code>模式，把项目移动到<code>$GOPATH/src</code>外</li><li>进入目录，运行 <code>go mod init [模块名称]</code></li><li><code>go build</code> 或者 <code>go run</code> 一次</li></ol><h2 id=问题五mod形式下如何下载指定版本的包>问题五：mod形式下如何下载指定版本的包</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>// 注意：项目目录下操作
$ go get github.com/isbrick/tools@c87b277
$ go mod vendor
</code></pre></div><p><strong>注</strong>: 根据官方的说法，从Go 1.13开始，模块管理模式将是Go语言开发的默认模式。</p><h2 id=问题六go-如何-import-private的代码仓库的包>问题六：Go 如何 import private的代码仓库的包</h2><p>对于 public 的仓库，大家知道是可以直接import的，而对于 private 代码仓库我们则需要如下操作：</p><h3 id=对于本地开发环境>对于本地开发环境</h3><ol><li>The Because of go module proxy site just like Maven default repo go also has a proxy site(<a href=https://proxy.golang.org>https://proxy.golang.org</a>,direct), 所以我们需要通过声明<code>GOPRIVATE</code>环境变量来绕过, 如果 <code>GOPRIVATE</code>有多个值通过逗号来分隔。</li></ol><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#888>## eg</span>
$ go env -w <span style=color:#963>GOPRIVATE</span><span style=color:#333>=</span>gitlab.repoxxx.com/<span style=color:#333>[</span>groupName<span style=color:#333>]</span>
$ go env -w <span style=color:#963>GOPRIVATE</span><span style=color:#333>=</span>gitlab.repo1.com,gitlab.repo2.com
</code></pre></div><p><strong>注</strong>: <strong>The new <code>GOPRIVATE</code> environment variable indicates module paths that are not publicly available.</strong> It serves as the default value for the lower-level GONOPROXY and GONOSUMDB variables, which provide finer-grained control over which modules are fetched via proxy and verified using the checksum database.</p><ol start=2><li>添加 access_token或是 ssh key 解决私有仓库的验证问题。</li></ol><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#888># access_token 可以在对应用户下配置</span>
$ git config --global url.<span style=background-color:#fff0f0>&#34;https://</span><span style=background-color:#eee>${</span><span style=color:#963>username</span><span style=background-color:#eee>}</span><span style=background-color:#fff0f0>:</span><span style=background-color:#eee>${</span><span style=color:#963>access_token</span><span style=background-color:#eee>}</span><span style=background-color:#fff0f0>@private.gitrepo.com&#34;</span>.insteadOf /
<span style=background-color:#fff0f0>&#34;https://private.gitrepo.com&#34;</span>

<span style=color:#888># Or use ssh-key 将私钥放置下对应的用户下</span>
<span style=color:#888># 也许，这个 ssh-key 私钥的并不是默认路径，那么你可以通过这个方式指定</span>
<span style=color:#888># $ cat ~/.ssh/config</span>
<span style=color:#888># Host yourserver</span>
<span style=color:#888>#     Hostname something.domain.tld</span>
<span style=color:#888>#     IdentityFile /var/www/html/ma.ttias.be/.ssh/id_rsa</span>
<span style=color:#888>#     IdentitiesOnly yes</span>
$ git config --global url.<span style=background-color:#fff0f0>&#34;git@yourserver&#34;</span>.insteadOf /
<span style=background-color:#fff0f0>&#34;https://yourserver&#34;</span>
</code></pre></div><p><strong>特别说明</strong>： 不论使用<code>access_token</code>或是<code>ssh key</code>, 强烈建议使用独立的用户，另外对于步骤2中insteadOf 的地址建议尽量再细, 避免其他的同站下的git项目产生影响, 如下：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ cat ~/.gitconfig  |grep url -A3
<span style=color:#333>[</span>url <span style=background-color:#fff0f0>&#34;http://goget:b9e6b3cafbf5789d74bdce16@gogs.domain.com/rudder/drone.git/dist&#34;</span><span style=color:#333>]</span>
	<span style=color:#963>insteadOf</span> <span style=color:#333>=</span> http://gogs.domain.com/rudder/drone.git/dist
</code></pre></div><h3 id=对于cicd>对于CI/CD</h3><p>如果你的项目已经将<code>vendor</code>随代码一起提交，那么你 go build 时可以直接用 <code>-mod vendor</code>的方式来 build, 倘若你的项目里没有管理<code>vendor</code>项目，那么<code>Dockerfile</code>里也要有类似于 <strong>对于本地开发环境</strong> 的设置。</p><p><code>Dockerfile</code>部分示例</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile>...<span style=color:red;background-color:#faa>
</span><span style=color:red;background-color:#faa></span><span style=color:#080;font-weight:700>RUN</span> go env -w <span style=color:#963>GOPRIVATE</span><span style=color:#333>=</span>github.com/colynn<span style=color:red;background-color:#faa>
</span><span style=color:red;background-color:#faa></span><span style=color:#888># 确认 build 环境里包含 git command</span><span style=color:red;background-color:#faa>
</span><span style=color:red;background-color:#faa></span><span style=color:#080;font-weight:700>RUN</span> apk add git<span style=color:red;background-color:#faa>
</span><span style=color:red;background-color:#faa></span><span style=color:#080;font-weight:700>RUN</span> git config --global url.<span style=background-color:#fff0f0>&#34;https://golang:&lt;access-token&gt;@github.com/colynn/tools&#34;</span>.insteadOf <span style=background-color:#fff0f0>&#34;https://github.com/colynn/tools&#34;</span><span style=color:red;background-color:#faa>
</span><span style=color:red;background-color:#faa></span>...<span style=color:red;background-color:#faa>
</span></code></pre></div></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Colynn.Liu</span></p><p class=copyright-item><span>Link:</span>
<a href=https://colynn.github.io/2019-08-15-introducing_go_mod/>https://colynn.github.io/2019-08-15-introducing_go_mod/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://colynn.github.io/tags/go/>#go</a></span>
<span class=tag><a href=https://colynn.github.io/tags/go-mod/>#go mod</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://colynn.github.io/>home</a></span></section></div><div class=post-nav><a href=https://colynn.github.io/2019-07-26-basic_knowledge_summarizing/ class=prev rel=prev title="python 语法汇总"><i class="iconfont icon-left"></i>&nbsp;python 语法汇总</a>
<a href=https://colynn.github.io/2019-09-15-kubespray-deploy-k8s/ class=next rel=next title="Kubespary 部署 Kubernetes 1.15.3 版本">Kubespary 部署 Kubernetes 1.15.3 版本&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script>const gitalk=new Gitalk({clientID:'7196948b9a586a342072',clientSecret:"1acf6a13bc1ce7b8d8e3554789781ba2aaa4575c",repo:"blog-comments",owner:"colynn",admin:"colynn",id:"/2019-08-15-introducing_go_mod/",distractionFreeMode:false,perPage:100});gitalk.render('gitalk-container')</script></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2018 - 2021</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://colynn.github.io/>Colynn.Liu</a> |</span>
<span><a href=https://colynn.github.io/friends>友情链接</a></span></div></footer><script src=/js/vendor_no_gallery.min.js async></script></div></body></html>