<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Colynn.Liu"><meta name=description content="Full-Stack DevOps, Be focused and Practical"><link rel=prev href=https://colynn.github.io/2019-07-26-basic_knowledge_summarizing/><link rel=next href=https://colynn.github.io/2019-09-15-kubespray-deploy-k8s/><link rel=canonical href=https://colynn.github.io/2019-08-15-introducing_go_mod/><link rel=apple-touch-icon sizes=180x180 href=/img/home-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Go Mod 包管理 & gRPC、Protobuf扫盲 | Colynn.Liu
</title><meta name=title content="Go Mod 包管理 & gRPC、Protobuf扫盲 | Colynn.Liu"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/colynn.github.io\/"},"articleSection":"posts","name":"Go Mod 包管理 \u0026 gRPC、Protobuf扫盲","headline":"Go Mod 包管理 \u0026 gRPC、Protobuf扫盲","description":"\u003ch2 id=\u0022前言\u0022\u003e前言\u003c\/h2\u003e\n\u003cp\u003eIn Go 1.11, a new tool has arrived. It\u0026rsquo;s called go mod. For those who don\u0026rsquo;t know what is that, I\u0026rsquo;ll tell you about it.\u003c\/p\u003e\n\u003cp\u003eOne of the purposes of this tool is to get rid of \u003ccode\u003e$GOPATH\u003c\/code\u003e, so you can git clone a Golang repository anywhere and work on it without worrying about $GOPATH at all. There are other purposes of course, such as simpler versioning and usage, but I think the RIP \u003ccode\u003e$GOPATH\u003c\/code\u003e is the most notable.\u003c\/p\u003e","inLanguage":"zh-CN","author":"Colynn.Liu","creator":"Colynn.Liu","publisher":"Colynn.Liu","accountablePerson":"Colynn.Liu","copyrightHolder":"Colynn.Liu","copyrightYear":"2019","datePublished":"2019-08-15 00:00:00 \u002b0000 UTC","dateModified":"2019-08-15 00:00:00 \u002b0000 UTC","url":"https:\/\/colynn.github.io\/2019-08-15-introducing_go_mod\/","wordCount":"4133","keywords":["go","go mod","Colynn.Liu"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/ title>文章</a>
<a class=menu-item href=/categories/ title>分类</a>
<a class=menu-item href=/tags/ title>标签</a>
<a class=menu-item href=/readings/ title>书单</a>
<a class=menu-item href=/aboutme/ title>关于我</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/ title>文章</a>
<a class=menu-item href=/categories/ title>分类</a>
<a class=menu-item href=/tags/ title>标签</a>
<a class=menu-item href=/readings/ title>书单</a>
<a class=menu-item href=/aboutme/ title>关于我</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">Go Mod 包管理 & gRPC、Protobuf扫盲</h1><div class=post-meta>Written by <a itemprop=name href=https://colynn.github.io/ rel=author>Colynn.Liu</a> with ♥
<span class=post-time>on <time datetime=2019-08-15 itemprop=datePublished>August 15, 2019</time>
</span><span class=post-time>- last modified on <time datetime=2019-08-15 itemprop=datePublished>February 25, 2025</time></span></div><div class=post-tags><section><span class=tag><a href=https://colynn.github.io/tags/go/><i class="iconfont icon-tag"></i>go</a></span>
<span class=tag><a href=https://colynn.github.io/tags/go-mod/><i class="iconfont icon-tag"></i>go mod</a></span></section><section></section></div></header><div class=post-content><h2 id=前言>前言</h2><p>In Go 1.11, a new tool has arrived. It&rsquo;s called go mod. For those who don&rsquo;t know what is that, I&rsquo;ll tell you about it.</p><p>One of the purposes of this tool is to get rid of <code>$GOPATH</code>, so you can git clone a Golang repository anywhere and work on it without worrying about $GOPATH at all. There are other purposes of course, such as simpler versioning and usage, but I think the RIP <code>$GOPATH</code> is the most notable.</p><p>If the repository is a mod, all the tools you use regularly (<code>go get</code>, <code>go build</code>, etc.) will handle it nicely without changing anything.</p><h2 id=如何使用-modules>如何使用 Modules</h2><p>把 golang 升级到 1.11</p><p>设置 GO111MODULE</p><p><code>go mod init [module-name]</code>. Yep, that&rsquo;s all you have to do. If you&rsquo;re trying to go mod-ify an existing project that uses $GOPATH, you should export the <code>GO111MODULE=on</code> variable (<code>go mod</code> will tell you that as well).</p><h2 id=go111module>GO111MODULE</h2><p>GO111MODULE 有三个值：off, on和auto（默认值）。</p><ul><li>GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。</li><li>GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。</li><li>GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：<ul><li>当前目录在GOPATH/src之外且该目录包含go.mod文件</li><li>当前文件在包含go.mod文件的目录下面。</li></ul></li></ul><p><strong>注</strong>: 当modules 功能启用时，依赖包的存放位置变更为$GOPATH/pkg/mod，允许同一个package多个版本并存，且多个项目可以共享缓存的 module。</p><h2 id=how-it-work>How it work</h2><p>再你初始化 go mod 后，如何让你的项目依赖一下第三方包，以大部分人都熟悉的beego为例吧！
修改Hello.go文件：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#080;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>import</span> <span style=background-color:#fff0f0>&#34;github.com/astaxie/beego&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    beego.<span style=color:#06b;font-weight:700>Run</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=1之前做法>1.之前做法</h3><p>要运行hello.go需要执行go get 命令 下载beego包到 <code>$GOPATH/src</code></p><h3 id=2当前推荐做法>2.当前推荐做法</h3><p>直接 <code>go run hello.go</code></p><p>稍等片刻… go 会自动查找代码中的包，下载依赖包，并且把具体的依赖关系和版本写入到go.mod和go.sum文件中。
查看go.mod，它会变成这样：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>module hello
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>go</span> <span style=color:#60e;font-weight:700>1.12</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>require github.com<span style=color:#333>/</span>astaxie<span style=color:#333>/</span>beego v1<span style=color:#60e;font-weight:700>.11.1</span>
</span></span></code></pre></div><h3 id=3-gomod文件解释>3. go.mod文件解释</h3><p>require 关键子是引用，后面是包，最后v1.11.1 是引用的版本号； 这样，一个使用Go包管理方式创建项目的小例子就完成了。</p><h2 id=问题一-依赖包的版本是怎么控制的>问题一： 依赖包的版本是怎么控制的？</h2><p>下载的依赖包 （<code>$GOPATH/pkg/mod</code>）是存在版本定义的（如：github.com/astaxie/beego@v1.11.1 ）最后会有一个版本号 1.11.1，也就是说，<code>$GOPATH/pkg/mod</code>里可以保存相同包的不同版本。</p><p>版本是在go.mod中指定的:</p><ul><li><p>如果，在go.mod中没有指定，go命令会自动下载代码中的依赖的最新版本，本例就是自动下载最新的版本。</p></li><li><p>如果，在go.mod用require语句指定包和版本 ，go命令会根据指定的路径和版本下载包，
指定版本时可以用latest，这样它会自动下载指定包的最新版本；</p></li></ul><h3 id=依赖包的版本号是什么>依赖包的版本号是什么？</h3><p>是包的发布者标记的版本号，格式为 vn.n.n (n代表数字)，本例中的beego的历史版本可以在其代码仓库release看到Releases · astaxie/beego · GitHub</p><p>如果包的作者还没有标记版本，默认为 v0.0.0</p><h2 id=问题二-依赖包中的地址失效了怎么办>问题二： 依赖包中的地址失效了怎么办？</h2><p>比如 golang.org/x/… 下的包都无法下载怎么办？
在go快速发展的过程中，有一些依赖包地址变更了。
以前的做法</p><p>修改源码，用新路径替换import的地址
git clone 或 go get 新包后，copy到$GOPATH/src里旧的路径下
无论什么方法，都不便于维护，特别是多人协同开发时。</p><p>使用go.mod就简单了，在go.mod文件里用 replace 替换包，例如</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>replace golang.org<span style=color:#333>/</span>x<span style=color:#333>/</span>text =&gt; github.com<span style=color:#333>/</span>golang<span style=color:#333>/</span>text latest
</span></span></code></pre></div><p>这样，go会用 <code>github.com/golang/text</code> 替代<code>golang.org/x/text</code>，原理就是下载<code>github.com/golang/text</code> 的最新版本到 <code>$GOPATH/pkg/mod/golang.org/x/text</code>下。</p><h2 id=问题三-init生成的gomod的模块名称有什么用>问题三： init生成的go.mod的模块名称有什么用？</h2><p>本例里，用 go mod init hello 生成的go.mod文件里的第一行会申明
module hello</p><p>因为我们的项目已经不在$GOPATH/src里了，那么引用自己怎么办？就用模块名+路径。</p><p>例如，在项目下新建目录 utils，创建一个tools.go文件:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#080;font-weight:700>package</span> utils
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>import</span> <span style=color:red;background-color:#faa>“</span>fmt<span style=color:red;background-color:#faa>”</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>PrintText</span>(text <span style=color:#339;font-weight:700>string</span>) {
</span></span><span style=display:flex><span>    fmt.<span style=color:#06b;font-weight:700>Println</span>(text)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在根目录下的hello.go文件就可以 import “hello/utils” 引用utils</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#080;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>import</span> (
</span></span><span style=display:flex><span><span style=background-color:#fff0f0>&#34;hello/utils&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=background-color:#fff0f0>&#34;github.com/astaxie/beego&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    utils.<span style=color:#06b;font-weight:700>PrintText</span>(<span style=background-color:#fff0f0>&#34;Hi&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    beego.<span style=color:#06b;font-weight:700>Run</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=问题四以前老项目如何用新的包管理>问题四：以前老项目如何用新的包管理</h2><ol><li>如果用<code>auto</code>模式，把项目移动到<code>$GOPATH/src</code>外</li><li>进入目录，运行 <code>go mod init [模块名称]</code></li><li><code>go build</code> 或者 <code>go run</code> 一次</li></ol><h2 id=问题五mod形式下如何下载指定版本的包>问题五：mod形式下如何下载指定版本的包</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>// 注意：项目目录下操作
</span></span><span style=display:flex><span>$ go get github.com/isbrick/tools@c87b277
</span></span><span style=display:flex><span>$ go mod vendor
</span></span></code></pre></div><p><strong>注</strong>: 根据官方的说法，从Go 1.13开始，模块管理模式将是Go语言开发的默认模式。</p><h2 id=问题六go-如何-import-private的代码仓库的包>问题六：Go 如何 import private的代码仓库的包</h2><p>对于 public 的仓库，大家知道是可以直接import的，而对于 private 代码仓库我们则需要如下操作：</p><h3 id=对于本地开发环境>对于本地开发环境</h3><ol><li>The Because of go module proxy site just like Maven default repo go also has a proxy site(<a href=https://proxy.golang.org,direct>https://proxy.golang.org,direct</a>), 所以我们需要通过声明<code>GOPRIVATE</code>环境变量来绕过, 如果 <code>GOPRIVATE</code>有多个值通过逗号来分隔。</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>go env -w <span style=color:#963>GOPRIVATE</span><span style=color:#333>=</span>git.repoxxx.com/<span style=color:#333>[</span>groupName<span style=color:#333>]</span>
</span></span></code></pre></div><p><strong>注</strong>: <strong>The new <code>GOPRIVATE</code> environment variable indicates module paths that are not publicly available.</strong> It serves as the default value for the lower-level GONOPROXY and GONOSUMDB variables, which provide finer-grained control over which modules are fetched via proxy and verified using the checksum database.</p><ol start=2><li>添加 access_token或是 ssh key 解决私有仓库的验证问题。</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#888># access_token 可以在对应用户下配置</span>
</span></span><span style=display:flex><span>$ git config --global url.<span style=background-color:#fff0f0>&#34;https://</span><span style=background-color:#eee>${</span><span style=color:#963>username</span><span style=background-color:#eee>}</span><span style=background-color:#fff0f0>:</span><span style=background-color:#eee>${</span><span style=color:#963>access_token</span><span style=background-color:#eee>}</span><span style=background-color:#fff0f0>@private.gitrepo.com&#34;</span>.insteadOf /
</span></span><span style=display:flex><span><span style=background-color:#fff0f0>&#34;https://private.gitrepo.com&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888># Or use ssh-key 将私钥放置下对应的用户下</span>
</span></span><span style=display:flex><span><span style=color:#888># 也许，这个 ssh-key 私钥的并不是默认路径，那么你可以通过这个方式指定</span>
</span></span><span style=display:flex><span><span style=color:#888># $ cat ~/.ssh/config</span>
</span></span><span style=display:flex><span><span style=color:#888># Host yourserver</span>
</span></span><span style=display:flex><span><span style=color:#888>#     Hostname something.domain.tld</span>
</span></span><span style=display:flex><span><span style=color:#888>#     IdentityFile /var/www/html/ma.ttias.be/.ssh/id_rsa</span>
</span></span><span style=display:flex><span><span style=color:#888>#     IdentitiesOnly yes</span>
</span></span><span style=display:flex><span>$ git config --global url.<span style=background-color:#fff0f0>&#34;git@yourserver&#34;</span>.insteadOf /
</span></span><span style=display:flex><span><span style=background-color:#fff0f0>&#34;https://yourserver&#34;</span>
</span></span></code></pre></div><p><strong>特别说明</strong>： 不论使用<code>access_token</code>或是<code>ssh key</code>, 强烈建议使用独立的用户，另外对于步骤2中insteadOf 的地址建议尽量再细, 避免其他的同站下的git项目产生影响, 如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ cat ~/.gitconfig  |grep url -A3
</span></span><span style=display:flex><span><span style=color:#333>[</span>url <span style=background-color:#fff0f0>&#34;http://goget:b9e6b3cafbf5789d74bdce16@gogs.domain.com/rudder/drone.git/dist&#34;</span><span style=color:#333>]</span>
</span></span><span style=display:flex><span> <span style=color:#963>insteadOf</span> <span style=color:#333>=</span> http://gogs.domain.com/rudder/drone.git/dist
</span></span></code></pre></div><h3 id=对于cicd>对于CI/CD</h3><p>如果你的项目已经将<code>vendor</code>随代码一起提交，那么你 go build 时可以直接用 <code>-mod vendor</code>的方式来 build, 倘若你的项目里没有管理<code>vendor</code>项目，那么<code>Dockerfile</code>里也要有类似于 <strong>对于本地开发环境</strong> 的设置。</p><p><code>Dockerfile</code>部分示例</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span>...<span style=color:red;background-color:#faa>
</span></span></span><span style=display:flex><span><span style=color:red;background-color:#faa></span><span style=color:#080;font-weight:700>RUN</span> go env -w <span style=color:#963>GOPRIVATE</span><span style=color:#333>=</span>github.com/colynn<span style=color:red;background-color:#faa>
</span></span></span><span style=display:flex><span><span style=color:red;background-color:#faa></span><span style=color:#888># 确认 build 环境里包含 git command</span><span style=color:red;background-color:#faa>
</span></span></span><span style=display:flex><span><span style=color:red;background-color:#faa></span><span style=color:#080;font-weight:700>RUN</span> apk add git<span style=color:red;background-color:#faa>
</span></span></span><span style=display:flex><span><span style=color:red;background-color:#faa></span><span style=color:#080;font-weight:700>RUN</span> git config --global url.<span style=background-color:#fff0f0>&#34;https://golang:&lt;access-token&gt;@github.com/colynn/tools&#34;</span>.insteadOf <span style=background-color:#fff0f0>&#34;https://github.com/colynn/tools&#34;</span><span style=color:red;background-color:#faa>
</span></span></span><span style=display:flex><span><span style=color:red;background-color:#faa></span>...<span style=color:red;background-color:#faa>
</span></span></span></code></pre></div><h2 id=问题七go-mod-如何不确定依赖是从哪里引入的可以使用>问题七：go mod 如何不确定依赖是从哪里引入的，可以使用</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>go mod why -m &lt;依赖名&gt;
</span></span></code></pre></div><h2 id=grpc-扫盲>gRPC 扫盲</h2><ul><li><strong>最重要的注意各组件版本间的兼容性</strong></li></ul><h3 id=protobufprotocol-buffers>Protobuf（Protocol Buffers）</h3><p>Protobuf 是 Google 开发的一种数据序列化协议，用于高效地传输结构化数据。与 JSON 或 XML 等格式相比，Protobuf 具有更高的效率和更小的二进制大小。</p><p>主要特点：</p><ul><li>平台和语言无关：Protobuf 支持多种编程语言（如 Go、Java、C++ 等）。</li><li>高效：相比于 JSON 或 XML，Protobuf 的序列化和反序列化速度更快，生成的数据更小。</li><li>强类型：Protobuf 定义了一个非常强类型的语言，能精确描述消息结构（字段类型、字段顺序、默认值等）。</li></ul><h3 id=protoc>Protoc</h3><ul><li><code>Protoc</code>（Protocol Buffers Compiler）是一个用于将 <code>.proto</code> 文件（定义服务和消息格式的文件）编译成特定语言代码的工具，是Protobuf的编译器；</li><li>它是所有 Protobuf 项目的基础，用于生成编解码（serialization/deserialization）代码。</li></ul><h3 id=protoc-gen-go>protoc-gen-go</h3><ul><li><code>protoc-gen-go</code> 是 Protobuf 用于生成 Go 语言代码的 <strong>插件</strong>。</li><li>它从 <code>.proto</code> 文件生成 Go 语言文件，通常这些文件包含了用于序列化、反序列化、以及实现 gRPC 服务所需要的 Go 代码。</li><li><code>protoc-gen-go</code> 是 Protobuf 编译器的扩展插件，必须与 Protoc 一起使用。</li><li><code>protoc-gen-go-grpc</code>（Go 语言的 gRPC 代码生成插件）：用于生成 gRPC 服务器和客户端代码（从 protoc-gen-go 中拆分出来）。</li><li><code>go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</code></li><li><code>go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</code></li></ul><h3 id=protoc-gen-validate>protoc-gen-validate</h3><ul><li><code>github.com/envoyproxy/protoc-gen-validate</code></li><li>一个 Protocol Buffers（Protobuf）校验插件，用于在 Protobuf <code>.proto</code> 文件中定义字段级别的 数据验证规则，并生成相应的 Go（或其他语言）的代码，以在运行时进行数据校验。</li><li><code>github.com/envoyproxy/protoc-gen-validate</code> 曾经是 PGV（Protobuf 校验插件）的官方仓库，但现在已经被迁移到了 <code>github.com/bufbuild/protoc-gen-validate</code>。</li></ul><h3 id=grpc>gRPC</h3><ul><li>gRPC 是由 Google 开发的一个高性能、开源和通用的远程过程调用（RPC）框架。gRPC 通过 Protobuf 作为接口定义语言，支持跨语言的服务调用, 基于 HTTP/2 协议并使用 Protobuf 作为序列化协议。</li><li>gRPC 使用 protoc (Protobuf的编译器)生成的代码进行服务定义，并提供接口来执行客户端和服务端之间的通信。</li><li>跨语言支持：gRPC 支持多种语言，像是 Go、Java、Python、C++ 等。</li><li>双向流：gRPC 支持客户端和服务器之间的双向流通信，适合实时通信和大规模系统。</li></ul><h3 id=grpc-go>gRPC-go</h3><ul><li>The Go language implementation of gRPC. HTTP/2 based RPC</li><li>（即 gRPC 的 Go 语言实现）是 gRPC 官方提供的 Go 语言版本实现，允许开发者在 Go 环境中使用 gRPC。它与 gRPC 的核心功能相同，但专门针对 Go 语言进行了封装和优化。</li></ul><h3 id=grpc-gateway>grpc-gateway</h3><ul><li>grpc-gateway 是一个用于生成 RESTful HTTP API 接口的工具，基于 gRPC 服务。</li><li>它允许你使用 HTTP/JSON 通过代理调用 gRPC 服务，主要用于为 gRPC 服务提供兼容的 RESTful API 接口（比如从 Web 客户端访问 gRPC 服务）。</li><li>grpc-gateway v2: v2兼容 gRPC v1.40+ 及更高版本，v2 改进了 runtime.HTTPError 处理方式</li></ul><h3 id=protoc-gen-grpc-gateway>protoc-gen-grpc-gateway</h3><ul><li><p><strong>作为 protoc 插件</strong>，自动生成 HTTP API 转发到 gRPC 服务器的代码。</p></li><li><p>让 gRPC 服务能通过 HTTP+JSON 访问，而不是只能使用 gRPC 客户端。</p></li><li><p>确保 <code>grpc-gateway</code> 和 <code>protoc-gen-grpc-gateway</code> 版本匹配</p><ul><li>v2.x 需要 google.golang.org/protobuf</li><li>v1.x 需要 github.com/golang/protobuf</li><li>不能单独使用 protoc-gen-grpc-gateway, 需要配合 protoc-gen-go-grpc，否则无法生成 gRPC 代码。</li><li>v2 latest版本: <code>go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@latest</code></li></ul></li></ul><h3 id=openapiswagger>OpenAPI(Swagger)</h3><ul><li>v1: v1 使用 <code>protoc-gen-swagger</code> 生成的 OpenAPI 2.0 规范 JSON 需要手动调整</li><li><code>go install github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger@v1.16.0</code></li><li>v2: <code>protoc-gen-swagger</code> 在 gRPC-Gateway v2 被 <code>protoc-gen-openapi</code> 取代 (protoc使用示例 <code>--openapiv2_out . --openapiv2_opt logtostderr=true \</code>), 默认支持 OpenAPI 3.0，并改进了 JSON Schema 结构</li><li><code>go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapi@latest</code></li></ul><h3 id=gomod的pkg解释>go.mod的pkg解释</h3><ul><li><p><code>google.golang.org/grpc</code>: 是 Go 语言的 gRPC 框架</p><ul><li>生成 gRPC 客户端和服务器 的核心库。</li><li>提供 gRPC 连接管理（grpc.Dial）。</li><li>支持 gRPC 的流式通信、拦截器、中间件等功能。</li><li><code>protoc-gen-go-grpc</code> 依赖 grpc-go，要求__<code>grpc v1.64.0</code>__ 及以上。</li></ul></li><li><p><strong><code>google.golang.org/protobuf</code></strong>: Protocol Buffers 的 Go 语言实现</p><ul><li>提供 proto.Message 接口，定义 Protobuf 消息的基本操作。</li><li>支持 Protobuf 的序列化、反序列化（proto.Marshal、proto.Unmarshal）。</li><li>处理 <code>.pb.go</code> 代码文件的核心库，所有 .proto 生成的 Go 代码都依赖它。</li><li><code>protoc-gen-go</code> v1.20+ 之后，protoc-gen-go 开始使用 google.golang.org/protobuf 作为 Protobuf 运行时库，取代了老的 <code>github.com/golang/protobuf</code>。</li></ul></li></ul><table><thead><tr><th>组件</th><th>作用</th><th>版本要求</th></tr></thead><tbody><tr><td>protoc</td><td>编译 .proto 文件的核心工具</td><td>建议 v3.14+，支持新 protoc-gen-go 代码</td></tr><tr><td>protoc-gen-go</td><td>生成 .pb.go 文件的插件</td><td>v1.27+ 需要 <code>google.golang.org/protobuf</code>, 兼容 grpc-gateway v2</td></tr><tr><td>protoc-gen-go-grpc</td><td>生成 .pb.go 的 gRPC 代码</td><td>v1.3.0+ 兼容 grpc</td></tr><tr><td>protoc-gen-grpc-gateway</td><td>生成 REST API 网关代码, 依赖 <code>protoc-gen-go-grpc</code>，必须先生成 gRPC 代码</td><td>注意v1/v2版本对于protobuf的库依赖不同</td></tr><tr><td>google.golang.org/protobuf</td><td>Protobuf 运行时库</td><td>v1.34.0+ 兼容新 protoc-gen-go</td></tr><tr><td>google.golang.org/grpc</td><td>gRPC 服务器/客户端核心库</td><td>v1.40+ 兼容 protoc-gen-go-grpc</td></tr><tr><td>github.com/grpc-ecosystem/grpc-gateway/v2</td><td>Generates a reverse-proxy server which translates a RESTful JSON API into gRPC.</td><td>注意v1/v2对于protoc的库版本的依赖不同</td></tr></tbody></table><h3 id=protoc命令示例>protoc命令示例</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#888># grpc-gateway v1</span>
</span></span><span style=display:flex><span>protoc -I <span style=color:#963>$GOPATH</span>/pkg/mod/github.com/grpc-ecosystem/grpc-gateway@v1.16.0/third_party/googleapis <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>       -I <span style=color:#963>$GOPATH</span>/pkg/mod/github.com/envoyproxy/protoc-gen-validate@v0.6.7/validate <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>       -I <span style=color:#963>$proto_package</span> <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>       --proto_path<span style=color:#333>=</span><span style=color:#963>$proto_package</span> <span style=background-color:#fff0f0>&#34;</span><span style=color:#963>$protofile</span><span style=background-color:#fff0f0>&#34;</span> <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>       --go-grpc_out<span style=color:#333>=</span><span style=color:#963>paths</span><span style=color:#333>=</span>source_relative:<span style=color:#963>$pb_go_package</span> <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>       --grpc-gateway_out<span style=color:#333>=</span><span style=color:#963>logtostderr</span><span style=color:#333>=</span>true:allow_delete_body<span style=color:#333>=</span>true,paths<span style=color:#333>=</span>source_relative:<span style=color:#963>$pb_go_package</span> <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>       --swagger_out<span style=color:#333>=</span><span style=color:#963>logtostderr</span><span style=color:#333>=</span>true:<span style=color:#963>$swagger_package</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#888># grpc-gateway v2 </span>
</span></span><span style=display:flex><span><span style=color:#888># you should git clone googleapis firstly</span>
</span></span><span style=display:flex><span><span style=color:#888># git clone https://github.com/googleapis/googleapis.git $GOPATH/src/github.com/googleapis/googleapis</span>
</span></span><span style=display:flex><span>protoc  -I<span style=color:#963>$GOPATH</span>/src/github.com/googleapis/googleapis <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>    -I<span style=color:#080;font-weight:700>$(</span>go env GOPATH<span style=color:#080;font-weight:700>)</span>/pkg/mod/github.com/envoyproxy/protoc-gen-validate@0.6.7/validate <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>    -I <span style=color:#963>$proto_package</span> <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>    --go-grpc_out<span style=color:#333>=</span><span style=color:#963>paths</span><span style=color:#333>=</span>source_relative:<span style=color:#963>$pb_go_package</span> <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>    --grpc-gateway_out<span style=color:#333>=</span><span style=color:#963>logtostderr</span><span style=color:#333>=</span>true,allow_delete_body<span style=color:#333>=</span>true,paths<span style=color:#333>=</span>source_relative:<span style=color:#963>$pb_go_package</span> <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>    --openapiv2_out<span style=color:#333>=</span><span style=color:#963>logtostderr</span><span style=color:#333>=</span>true:<span style=color:#963>$swagger_package</span>
</span></span></code></pre></div><h3 id=todo-what-it-bufbuild>[TODO] what it bufbuild</h3></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Colynn.Liu</span></p><p class=copyright-item><span>Link:</span>
<a href=https://colynn.github.io/2019-08-15-introducing_go_mod/>https://colynn.github.io/2019-08-15-introducing_go_mod/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://colynn.github.io/tags/go/>#go</a></span>
<span class=tag><a href=https://colynn.github.io/tags/go-mod/>#go mod</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://colynn.github.io/>home</a></span></section></div><div class=post-nav><a href=https://colynn.github.io/2019-07-26-basic_knowledge_summarizing/ class=prev rel=prev title="python 语法汇总"><i class="iconfont icon-left"></i>&nbsp;python 语法汇总</a>
<a href=https://colynn.github.io/2019-09-15-kubespray-deploy-k8s/ class=next rel=next title="Kubespary 部署 Kubernetes 1.15.3 版本">Kubespary 部署 Kubernetes 1.15.3 版本&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script>const gitalk=new Gitalk({clientID:"7196948b9a586a342072",clientSecret:"1acf6a13bc1ce7b8d8e3554789781ba2aaa4575c",repo:"blog-comments",owner:"colynn",admin:"colynn",id:"/2019-08-15-introducing_go_mod/",distractionFreeMode:!1,perPage:100});gitalk.render("gitalk-container")</script></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2018 - 2025</span>
<span class=with-love><i class="iconfont icon-love"></i>
</span><span class=author itemprop=copyrightHolder><a href=https://colynn.github.io/>Colynn.Liu</a> | </span><span><a href=https://colynn.github.io/friends>友情链接</a></span></div></footer><script src=/js/vendor_no_gallery.min.js async></script></div></body></html>