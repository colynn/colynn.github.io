<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Colynn.Liu"><link rel=prev href=https://colynn.github.io/2020-04-10-kubernetes-networking-flannel-calico/><link rel=next href=https://colynn.github.io/2020-05-25-jwt-auth/><link rel=canonical href=https://colynn.github.io/2020-05-06-slice-internal/><link rel=apple-touch-icon sizes=180x180 href=/img/home-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Go Slice 内部发生了什么 | Colynn.Liu</title><meta name=title content="Go Slice 内部发生了什么 | Colynn.Liu"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/colynn.github.io\/"},"articleSection":"posts","name":"Go Slice 内部发生了什么","headline":"Go Slice 内部发生了什么","description":"前言 Go\u0026rsquo;s Slice类型为处理类型化数据序列提供了一种方便且高效的方法。 Slice internals slice是一个array片段的描述符，它包含一个指向数组的指针，版","inLanguage":"zh-CN","author":"Colynn.Liu","creator":"Colynn.Liu","publisher":"Colynn.Liu","accountablePerson":"Colynn.Liu","copyrightHolder":"Colynn.Liu","copyrightYear":"2020","datePublished":"2020-05-06 00:00:00 \u002b0000 UTC","dateModified":"2020-05-06 00:00:00 \u002b0000 UTC","url":"https:\/\/colynn.github.io\/2020-05-06-slice-internal\/","wordCount":"1209","keywords":["go","slice","Colynn.Liu"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">Go Slice 内部发生了什么</h1><div class=post-meta>Written by <a itemprop=name href=https://colynn.github.io/ rel=author>Colynn.Liu</a> with ♥
<span class=post-time>on <time datetime=2020-05-06 itemprop=datePublished>May 6, 2020</time></span>
<span class=post-time>- last modified <time datetime=2020-05-06 itemprop=datePublished>May 6, 2020</time></span></div><div class=post-tags><section><span class=tag><a href=https://colynn.github.io/tags/go/><i class="iconfont icon-tag"></i>go</a></span>
<span class=tag><a href=https://colynn.github.io/tags/slice/><i class="iconfont icon-tag"></i>slice</a></span></section><section><i class="iconfont icon-folder"></i><span class=post-category><a href=https://colynn.github.io/categories/%E6%95%99%E7%A8%8B/>教程</a></span></section></div></header><div class=post-content><h2 id=前言>前言</h2><p>Go&rsquo;s Slice类型为处理类型化数据序列提供了一种方便且高效的方法。</p><h2 id=slice-internals>Slice internals</h2><p>slice是一个array片段的描述符，它包含一个指向数组的指针，版本的长度，还有它的容量。</p><p><img src=https://user-images.githubusercontent.com/5203608/89412331-78fb0780-d759-11ea-8755-2344e7e04617.png alt=image></p><p>假如我们声明一个变量 <code>s = make([]byte, 5)</code> , 那它的存储形式类似这样：</p><p><img src=https://user-images.githubusercontent.com/5203608/89412365-87e1ba00-d759-11ea-850e-1a81e628cf6c.png alt=image></p><p><em>注</em>: 长度<code>length</code>是切片引用的元素数, 容量<code>capacity</code>是底层数组中的元素数(从切片指针引用的元素开始).</p><p><em>注：</em> The length is the number of elements referred to by the slice. The capacity is the number of elements in the underlying array (beginning at the element referred to by the slice pointer)</p><p>正如我们基于slice <code>s</code>, 重新赋值<code>s = s[2:4]</code>，那么slice的数据结构应该如下(长度为2， 容量为3)：</p><p><img src=https://user-images.githubusercontent.com/5203608/89412380-8fa15e80-d759-11ea-84d1-5aa19a1123a5.png alt=image></p><p>Slice 不会拷贝slice的数据，它会创建一个指向原始数组的新slice. 也正是因为这样, 使slice的如操作arry的索引一样高效。因此， 修改重新切片的元素(而不是切片本身)会修改原始切片的元素。</p><h3 id=示例>示例</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>SubtractOneFromLength</span>(slice []<span style=color:#339;font-weight:700>byte</span>) []<span style=color:#339;font-weight:700>byte</span> {
	slice = slice[<span style=color:#00d;font-weight:700>0</span> : <span style=color:#007020>len</span>(slice)<span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>]
	<span style=color:#080;font-weight:700>return</span> slice
}

<span style=color:#080;font-weight:700>var</span> buffer [<span style=color:#00d;font-weight:700>256</span>]<span style=color:#339;font-weight:700>byte</span>

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	slice <span style=color:#333>:=</span> buffer[<span style=color:#00d;font-weight:700>10</span>:<span style=color:#00d;font-weight:700>20</span>]
	<span style=color:#080;font-weight:700>for</span> i <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>0</span>; i &lt; <span style=color:#007020>len</span>(slice); i<span style=color:#333>++</span> {
		slice[i] = <span style=color:#007020>byte</span>(i)
	}
	fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;Before: len(slice) =&#34;</span>, <span style=color:#007020>len</span>(slice))
	newSlice <span style=color:#333>:=</span> <span style=color:#06b;font-weight:700>SubtractOneFromLength</span>(slice)

	fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;After:  len(slice) =&#34;</span>, <span style=color:#007020>len</span>(slice))
	fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;After:  len(newSlice) =&#34;</span>, <span style=color:#007020>len</span>(newSlice))
}

</code></pre></div><p>通过上面的函数，我们可以修改 slice 的内容，但是它的头部信息不能被修改。slice的长度不会被修改通过调用函数，因为函数传输的一个原有 slice 的拷贝， 而不是原有的slice。</p><p>因为如果我们想修改 slice 的头部信息，我们必须返回 slice本身作为一个结果参数。如上面的函数一样，函数返回一个新的长度，然后赋值给<code>newSlice</code>.</p><p>或者是处理函数时我们使用指针，如下面的函数：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>SubtractOneFromLength</span>(slice <span style=color:#333>*</span>[]<span style=color:#339;font-weight:700>byte</span>) <span style=color:#333>*</span>[]<span style=color:#339;font-weight:700>byte</span> {
	slicepr <span style=color:#333>:=</span> <span style=color:#333>*</span>slice
	<span style=color:#333>*</span>slice = slicepr[<span style=color:#00d;font-weight:700>0</span> : <span style=color:#007020>len</span>(<span style=color:#333>*</span>slice)<span style=color:#333>-</span><span style=color:#00d;font-weight:700>1</span>]
	<span style=color:#080;font-weight:700>return</span> slice
}

<span style=color:#080;font-weight:700>var</span> buffer [<span style=color:#00d;font-weight:700>256</span>]<span style=color:#339;font-weight:700>byte</span>

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	slice <span style=color:#333>:=</span> buffer[<span style=color:#00d;font-weight:700>10</span>:<span style=color:#00d;font-weight:700>20</span>]
	<span style=color:#080;font-weight:700>for</span> i <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>0</span>; i &lt; <span style=color:#007020>len</span>(slice); i<span style=color:#333>++</span> {
		slice[i] = <span style=color:#007020>byte</span>(i)
	}
	fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;Before: len(slice) =&#34;</span>, <span style=color:#007020>len</span>(slice))
	newSlice <span style=color:#333>:=</span> <span style=color:#06b;font-weight:700>SubtractOneFromLength</span>(<span style=color:#333>&amp;</span>slice)

	fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;After:  len(slice) =&#34;</span>, <span style=color:#007020>len</span>(slice))
	fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;After:  len(newSlice) =&#34;</span>, <span style=color:#007020>len</span>(<span style=color:#333>*</span>newSlice))
}
</code></pre></div><h2 id=growing-slices-the-copy-and-append-functions>Growing slices (the copy and append functions)</h2><p>为了增加slice的容量，必须创建一个更大的新的slice, 然后将原始的slice 内容拷贝进去。</p><p><strong>注解</strong>: 这种技术就是其他语言的动态数组实现如何在幕后工作的。</p><h3 id=copy>Copy</h3><p>使用built-in的<code>copy</code>函数. 拷贝原 slice 至目标 slice, 返回拷贝元素的个数。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>func</span> <span style=color:#007020>copy</span>(dst, src []T) <span style=color:#339;font-weight:700>int</span>
</code></pre></div><p>The copy function supports copying between slices of different lengths (it will copy only up to the smaller number of elements). In addition, copy can handle source and destination slices that share the same underlying array, handling overlapping slices correctly.</p><h3 id=append>Append</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>func</span> <span style=color:#007020>append</span>(s []T, x <span style=color:#333>...</span>T) []T
</code></pre></div><p><code>append</code> 函数添加 <code>x</code> 元素至 slice 的末尾，如果需要更大的容量，则增加切片。</p><h3 id=append-时间复杂度>Append 时间复杂度</h3><p><strong>概述</strong>：<code>append()</code>的摊销成本为O(1), 但最坏情况的成本为O(N).</p><p>示例代码：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#888>// main.go
</span><span style=color:#888></span><span style=color:#080;font-weight:700>package</span> main
<span style=color:#080;font-weight:700>var</span> size = <span style=color:#00d;font-weight:700>1</span> <span style=color:#333>&lt;&lt;</span> <span style=color:#00d;font-weight:700>20</span>
<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>Append</span>() {
   <span style=color:#080;font-weight:700>var</span> s []<span style=color:#339;font-weight:700>int</span>
   <span style=color:#080;font-weight:700>for</span> i <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>0</span>; i &lt; size; i<span style=color:#333>++</span> {
      s = <span style=color:#007020>append</span>(s, i)
   }
   _ = s
}
<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>Make</span>() {
   s <span style=color:#333>:=</span> <span style=color:#007020>make</span>([]<span style=color:#339;font-weight:700>int</span>, size)
   <span style=color:#080;font-weight:700>for</span> i <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>0</span>; i &lt; size; i<span style=color:#333>++</span> {
      s[i] = i
   }
   _ = s
}

</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#888>// main_test.go
</span><span style=color:#888></span><span style=color:#080;font-weight:700>package</span> main
<span style=color:#080;font-weight:700>import</span> <span style=background-color:#fff0f0>&#34;testing&#34;</span>
<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>BenchmarkAppend</span>(b <span style=color:#333>*</span>testing.B) {
   <span style=color:#080;font-weight:700>for</span> n <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>0</span>; n &lt; b.N; n<span style=color:#333>++</span> {
      <span style=color:#06b;font-weight:700>Append</span>()
   }
}
<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>BenchmarkMake</span>(b <span style=color:#333>*</span>testing.B) {
   <span style=color:#080;font-weight:700>for</span> n <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>0</span>; n &lt; b.N; n<span style=color:#333>++</span> {
      <span style=color:#06b;font-weight:700>Make</span>()
   }
}
</code></pre></div><p>运行结果 <code>go test -bench=.</code></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>goos: darwin
goarch: amd64
pkg: newops/tmp/slice-append
BenchmarkAppend-8            <span style=color:#60e;font-weight:700>302</span>           <span style=color:#60e;font-weight:700>3925864</span> ns/op
BenchmarkMake-8             <span style=color:#60e;font-weight:700>1353</span>            <span style=color:#60e;font-weight:700>886194</span> ns/op
PASS
ok      newops/tmp/slice-append 2.704s
</code></pre></div><p>从结果可以看出，如果我们创建带容量的<code>slice</code>, 可以节约将近88%的 CPU使用时间。</p><h2 id=结论>结论</h2><ol><li><code>append()</code>可以是昂贵的，尽管其摊销成本在理论上为O(1)。</li><li>当<code>slice</code>的大小较小时，分配内存可能是使用<code>slice</code>时最耗时的部分；当大小增加时，在内存中移动数据将占用更多的CPU时间。</li><li>如果我们知道<code>slice</code>的长度，我们应该使用 <code>make()</code>创建<code>slice</code>而不使用动态的追加<code>slice</code>。</li></ol><h2 id=参考>参考</h2><ol><li><a href=https://blog.golang.org/slices-intro>Go Slices: usage and internals</a></li><li><a href=https://blog.golang.org/slices>Array, slices(and strings): The mechanics of &lsquo;append&rsquo;</a></li><li><a href=https://medium.com/vendasta/golang-the-time-complexity-of-append-2177dcfb6bad>Golang: The time complexity of append()</a></li></ol></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Colynn.Liu</span></p><p class=copyright-item><span>Link:</span>
<a href=https://colynn.github.io/2020-05-06-slice-internal/>https://colynn.github.io/2020-05-06-slice-internal/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://colynn.github.io/tags/go/>#go</a></span>
<span class=tag><a href=https://colynn.github.io/tags/slice/>#slice</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://colynn.github.io/>home</a></span></section></div><div class=post-nav><a href=https://colynn.github.io/2020-04-10-kubernetes-networking-flannel-calico/ class=prev rel=prev title=kubernetes-网络组件-flannel-calico><i class="iconfont icon-left"></i>&nbsp;kubernetes-网络组件-flannel-calico</a>
<a href=https://colynn.github.io/2020-05-25-jwt-auth/ class=next rel=next title="Jwt web token - What & How & FAQ">Jwt web token - What & How & FAQ&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script>const gitalk=new Gitalk({clientID:'7196948b9a586a342072',clientSecret:"1acf6a13bc1ce7b8d8e3554789781ba2aaa4575c",repo:"blog-comments",owner:"colynn",admin:"colynn",id:"/2020-05-06-slice-internal/",distractionFreeMode:false,perPage:100});gitalk.render('gitalk-container')</script></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2018 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://colynn.github.io/>Colynn.Liu</a> |</span>
<span><a href=https://colynn.github.io/friends>友情链接</a></span></div></footer><link href=//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css rel=stylesheet><script src=/js/vendor_gallery.min.js async></script></div></body></html>