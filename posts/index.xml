<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Colynn.Liu</title><link>https://colynn.github.io/posts/</link><description>Recent content in Posts on Colynn.Liu</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Tue, 25 Feb 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://colynn.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>how to use PostgreSQL</title><link>https://colynn.github.io/2022-05-26-postgresql-in-using/</link><pubDate>Thu, 26 May 2022 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2022-05-26-postgresql-in-using/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;h2 id="架构">架构&lt;/h2>
&lt;h2 id="常用命令">常用命令&lt;/h2>
&lt;h3 id="连接">连接&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888"># connection&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">export&lt;/span> &lt;span style="color:#963">PGPASSWORD&lt;/span>&lt;span style="color:#333">=&lt;/span>examplepassword ; psql -h 127.0.0.1 -p &lt;span style="color:#60e;font-weight:bold">5432&lt;/span> -U admin -d database-name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建数据库">创建数据库&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">## create database, use binary file `createdb`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>createdb example001
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code># create database example001;
&lt;/code>&lt;/pre>&lt;h3 id="show-databases">show databases&lt;/h3>
&lt;ul>
&lt;li>Use &lt;code>\l&lt;/code> or &lt;code>\l+&lt;/code> in psql to show all databases in the current PostgreSQL server.&lt;/li>
&lt;li>Use the &lt;code>SELECT&lt;/code> statement to query data from the &lt;code>pg_database&lt;/code> to get all databases.&lt;/li>
&lt;/ul>
&lt;p>use &lt;code>\l&lt;/code> 或是 &lt;code>\l+&lt;/code> 获取到更多的信息；&lt;/p></description></item><item><title>理解并正确使用docker volume/bind mount</title><link>https://colynn.github.io/2022-05-02-docker-volume/</link><pubDate>Wed, 04 May 2022 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2022-05-02-docker-volume/</guid><description>&lt;h2 id="写在前面">写在前面&lt;/h2>
&lt;p>默认情况下，在容器内创建的所有文件都存储在一个可写的容器层上(如下图)，&lt;/p>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/5203608/166707397-5e8d89b4-78b9-4813-a67e-c180a083af98.png" alt="Image">&lt;/p>
&lt;h3 id="问题">问题&lt;/h3>
&lt;p>但是这也带来如下的几个问题：&lt;/p>
&lt;ul>
&lt;li>当该容器不再存在时，数据并不持久，而且如果另一个进程需要这些数据，就很难将其从容器中取出。&lt;/li>
&lt;li>容器的可写层与容器所运行的主机紧密相连。你不能轻易地把数据移到别的地方。&lt;/li>
&lt;li>写入容器的可写层需要一个存储驱动来管理文件系统。存储驱动提供了一个联合文件系统，使用Linux内核。与使用数据卷直接写在主机文件系统中，这种额外的抽象降低了性能。&lt;/li>
&lt;/ul>
&lt;h3 id="解决方案">解决方案&lt;/h3>
&lt;p>&lt;code>Docker&lt;/code>对于容器文件的持久化提供了两种方式：&lt;code>volumes&lt;/code>、&lt;code>bind mounts&lt;/code>&lt;/p></description></item><item><title>Kubernetes Operator</title><link>https://colynn.github.io/2021-08-12-k8s-operator/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2021-08-12-k8s-operator/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>Introduced in 2016 by &lt;strong>CoreOS&lt;/strong>, an Operator is a method of packaging, deploying and managine a Kubernetes application. A kubernetes application is an application that is both deployed on Kubernetes and managed using the Kubernetes APIs and Kubernetes tooling such as Kubectl.&lt;/p>
&lt;h2 id="how-to-create-opeartor">How to create opeartor&lt;/h2></description></item><item><title>理解https(ssl/tls)加密原理</title><link>https://colynn.github.io/2021-07-13-nginx-ssl/</link><pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2021-07-13-nginx-ssl/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>An HTTPS connection involves two parties: the client (the one who is initiating the connection, usually your web browser), and the server. These two parties are the ones that ‘shake hands.’ The purpose of the SSL/TLS handshake is to perform all the cryptographic work needed to have a secure connection. This includes authenticating the SSL certificate being used, and generating an encryption key.&lt;/p></description></item><item><title>Centos 8 Tips</title><link>https://colynn.github.io/2021-05-18-centos8-tips/</link><pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2021-05-18-centos8-tips/</guid><description>&lt;h2 id="系统yum源调整">系统yum源调整&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888"># centos 8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888"># centos 7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888"># centos 6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="active-ip-addr-on-centos-8">Active ip addr on centos 8&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>nmcli c r eth0 ; nmcli d r eth0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>K8s常用命令备注手册</title><link>https://colynn.github.io/2020-11-04-kubernetes-cheat-sheet/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-11-04-kubernetes-cheat-sheet/</guid><description>&lt;h2 id="pod">Pod&lt;/h2>
&lt;ol>
&lt;li>pod 进入指定的 container&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888"># Name of the container: kaniko&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888"># Name of the pod: jnlp-gjrpc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ kubectl &lt;span style="color:#007020">exec&lt;/span> -ti jnlp-gjrpc -c kaniko /bin/sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>强制删除 pod&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ kubectl delete pods mypod-ba97bc8ef-8rgaa --grace-period&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#60e;font-weight:bold">0&lt;/span> --force
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="label">Label&lt;/h2>
&lt;ol>
&lt;li>create a label for a node:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ kubectl label node &amp;lt;nodename&amp;gt; &amp;lt;labelname&amp;gt;&lt;span style="color:#333">=&lt;/span>&amp;lt;value&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>delete above labels from its node&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ kubectl label node &amp;lt;nodename&amp;gt; &amp;lt;labelname&amp;gt;-
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>confirm node labels&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ kubectl get nodes --show-labels
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="helm">Helm&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>helm get --revision &lt;span style="color:#60e;font-weight:bold">0&lt;/span> engine-realtime-clustering-service-nebula | head
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>持续的GitOps, 是时候启用了吗？</title><link>https://colynn.github.io/2020-09-21-gitops/</link><pubDate>Mon, 21 Sep 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-09-21-gitops/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>对于DevOps是不是大家均已经很熟悉，每论你的公司大与小也许你都已经存在了一个devops平台或是工具链，用来辅助环境配置、应用发布、监控等方面。&lt;/p></description></item><item><title>HTTP 协议 - 理解</title><link>https://colynn.github.io/2020-08-11-http-protocol/</link><pubDate>Mon, 24 Aug 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-08-11-http-protocol/</guid><description>&lt;h1 id="概述">概述&lt;/h1>
&lt;p>Web 浏览器、服务器和相关的 Web应用程序都是通过 HTTP 相互通信的。HTTP是现代全球因特网中使用的公共语言。&lt;/p>
&lt;p>HTTP使用的是可靠的数据传输协议，因此即使数据来自地球的另一端，它也能够确保数据在传输的过程中不会被损坏或产生混乱。&lt;/p></description></item><item><title>TCP/IP 协议</title><link>https://colynn.github.io/2020-08-11-tcp-ip/</link><pubDate>Tue, 11 Aug 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-08-11-tcp-ip/</guid><description>&lt;h2 id="基础知识">基础知识&lt;/h2>
&lt;h3 id="具体含义">具体含义&lt;/h3>
&lt;p>利用IP进行通信时所必须用到的协议的统称。 具体来说，IP 或 ICMP、TCP或 UDP、 TELNET或是 FTP、HTTP 等都属于 TCP/IP 的协议。它们与 TCP或 IP 的关系紧密，是互联网必不可以少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称TCP/IP为国际协议族。&lt;/p></description></item><item><title>npm使用过程中的报错记录</title><link>https://colynn.github.io/2020-06-19-npm-catch-error/</link><pubDate>Fri, 19 Jun 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-06-19-npm-catch-error/</guid><description>&lt;h2 id="1-制做docker镜像时无法安装依赖">1. 制做docker镜像时无法安装依赖&lt;/h2>
&lt;h3 id="问题描述">问题描述&lt;/h3>
&lt;p>比如你在package.json里指定了 对于本地包或是 git 包的依赖，然后你在本地直接打包(&lt;code>npm run build&lt;/code>)是没有问题的，但如果现在你想构建镜像，那么这么非常规的依赖可能会成为你的障碍。&lt;/p></description></item><item><title>ASCII, Unicode, UTF-8 字符编码</title><link>https://colynn.github.io/2020-06-11-unicode-utf8/</link><pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-06-11-unicode-utf8/</guid><description>&lt;h2 id="位字节字符">位、字节、字符&lt;/h2>
&lt;ul>
&lt;li>位（bit): 是计算机内部数据存储的最小单位,&lt;/li>
&lt;li>字节（byte): 计算机中数据处理的基本单位，习惯上用大写 B 来表示， &lt;code>1B(byte) = 8bit&lt;/code>&lt;/li>
&lt;li>字符： 计算机中使用的字母、数字、字, 是一个信息单位。&lt;/li>
&lt;/ul>
&lt;h2 id="ascii-编码">ASCII 编码&lt;/h2>
&lt;p>我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。&lt;/p></description></item><item><title>vue 使用中的汇总</title><link>https://colynn.github.io/2020-06-01-vue-in-using-summaring/</link><pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-06-01-vue-in-using-summaring/</guid><description>&lt;h1 id="vue-生命周期">Vue 生命周期&lt;/h1>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/5203608/89412164-2e798b00-d759-11ea-82b8-324f3d18e5e4.png" alt="image">&lt;/p>
&lt;h1 id="vue-路由">Vue 路由&lt;/h1>
&lt;h2 id="1-vue-路由跳转方式">1. Vue 路由跳转方式&lt;/h2>
&lt;h3 id="1-router-link">1. router-link&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60e;font-weight:bold">1.&lt;/span>不带参数
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#333">&amp;lt;&lt;/span>router&lt;span style="color:#333">-&lt;/span>link &lt;span style="color:#333">:&lt;/span>to&lt;span style="color:#333">=&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;{name:&amp;#39;home&amp;#39;}&amp;#34;&lt;/span>&lt;span style="color:#333">&amp;gt;&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#333">&amp;lt;&lt;/span>router&lt;span style="color:#333">-&lt;/span>link &lt;span style="color:#333">:&lt;/span>to&lt;span style="color:#333">=&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;{path:&amp;#39;/home&amp;#39;}&amp;#34;&lt;/span>&lt;span style="color:#333">&amp;gt;&lt;/span> &lt;span style="color:#888">//name,path都行, 建议用name 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// 注意：router-link中链接如果是&amp;#39;/&amp;#39;开始就是从根路由开始，如果开始不带&amp;#39;/&amp;#39;，则从当前路由开始。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60e;font-weight:bold">2.&lt;/span>带参数
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#333">&amp;lt;&lt;/span>router&lt;span style="color:#333">-&lt;/span>link &lt;span style="color:#333">:&lt;/span>to&lt;span style="color:#333">=&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;{name:&amp;#39;home&amp;#39;, params: {id:1}}&amp;#34;&lt;/span>&lt;span style="color:#333">&amp;gt;&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// params传参数 (类似post)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// 路由配置 path: &amp;#34;/home/:id&amp;#34; 或者 path: &amp;#34;/home:id&amp;#34; 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// 不配置path ,第一次可请求,刷新页面id会消失
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// 配置path,刷新页面id会保留
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// html 取参 $route.params.id
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// script 取参 this.$route.params.id
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#333">&amp;lt;&lt;/span>router&lt;span style="color:#333">-&lt;/span>link &lt;span style="color:#333">:&lt;/span>to&lt;span style="color:#333">=&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;{name:&amp;#39;home&amp;#39;, query: {id:1}}&amp;#34;&lt;/span>&lt;span style="color:#333">&amp;gt;&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// query传参数 (类似get,url后面会显示参数)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// 路由可不配置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// html 取参 $route.query.id
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// script 取参 this.$route.query.id
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-thisrouterpush-函数里面调用">2. this.$router.push() (函数里面调用)&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60e;font-weight:bold">1.&lt;/span>不带参数
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">this&lt;/span>.$router.push(&lt;span style="background-color:#fff0f0">&amp;#39;/home&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">this&lt;/span>.$router.push({name&lt;span style="color:#333">:&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#39;home&amp;#39;&lt;/span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">this&lt;/span>.$router.push({path&lt;span style="color:#333">:&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#39;/home&amp;#39;&lt;/span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60e;font-weight:bold">2.&lt;/span> query传参 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">this&lt;/span>.$router.push({name&lt;span style="color:#333">:&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#39;home&amp;#39;&lt;/span>,query&lt;span style="color:#333">:&lt;/span> {id&lt;span style="color:#333">:&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#39;1&amp;#39;&lt;/span>}})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">this&lt;/span>.$router.push({path&lt;span style="color:#333">:&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#39;/home&amp;#39;&lt;/span>,query&lt;span style="color:#333">:&lt;/span> {id&lt;span style="color:#333">:&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#39;1&amp;#39;&lt;/span>}})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// html 取参 $route.query.id
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// script 取参 this.$route.query.id
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#60e;font-weight:bold">3.&lt;/span> params传参
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">this&lt;/span>.$router.push({name&lt;span style="color:#333">:&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#39;home&amp;#39;&lt;/span>,params&lt;span style="color:#333">:&lt;/span> {id&lt;span style="color:#333">:&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#39;1&amp;#39;&lt;/span>}}) &lt;span style="color:#888">// 只能用 name
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// 路由配置 path: &amp;#34;/home/:id&amp;#34; 或者 path: &amp;#34;/home:id&amp;#34; ,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// 不配置path ,第一次可请求,刷新页面id会消失
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// 配置path,刷新页面id会保留
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// html 取参 $route.params.id
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// script 取参 this.$route.params.id
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60e;font-weight:bold">4.&lt;/span> query和params区别
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>query类似 get, 跳转之后页面 url后面会拼接参数,类似&lt;span style="color:#333">?&lt;/span>id&lt;span style="color:#333">=&lt;/span>&lt;span style="color:#00d;font-weight:bold">1&lt;/span>, 非重要性的可以这样传, 密码之类还是用params刷新页面id还在
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3--thisrouterreplace-用法同上push">3. this.$router.replace() (用法同上,push)&lt;/h3>
&lt;h3 id="4--thisroutergon">4. this.$router.go(n)&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">this&lt;/span>.$router.go(n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>向前或者向后跳转n个页面&lt;span style="color:#f00;background-color:#faa">，&lt;/span>n可为正整数或负整数
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;code>this.$router.push&lt;/code> 跳转到指定url路径，并想history栈中添加一个记录，点击后退会返回到上一个页面&lt;/p></description></item><item><title>Jwt web token - What &amp; How &amp; FAQ</title><link>https://colynn.github.io/2020-05-25-jwt-auth/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-05-25-jwt-auth/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>JSON Web Token是符合&lt;a href="https://tools.ietf.org/html/rfc7519">RFC7519&lt;/a>标准的开放式行业标准方法，用于在双方之间安全地表示声明。&lt;/p>
&lt;h2 id="what-is-jwt">What is Jwt&lt;/h2>
&lt;p>Jwt可以分为三个部分, &lt;code>header&lt;/code>, &lt;code>payload&lt;/code>, &lt;code>signature&lt;/code>， 它们之前通过&lt;code>.&lt;/code>来分隔.&lt;/p>
&lt;ul>
&lt;li>&lt;code>HEADER&lt;/code> 描述生成&lt;code>signature&lt;/code>的具体算法。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f00;background-color:#faa">“alg”:&lt;/span> &lt;span style="color:#f00;background-color:#faa">“HS256”,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f00;background-color:#faa">“typ”:&lt;/span> &lt;span style="color:#f00;background-color:#faa">“JWT”&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;code>PAYLOAD&lt;/code> 所有的Jwt验证的声明都存储在这里。&lt;/p></description></item><item><title>Go Slice 内部发生了什么</title><link>https://colynn.github.io/2020-05-06-slice-internal/</link><pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-05-06-slice-internal/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>Go&amp;rsquo;s Slice类型为处理类型化数据序列提供了一种方便且高效的方法。&lt;/p>
&lt;h2 id="slice-internals">Slice internals&lt;/h2>
&lt;p>slice是一个array片段的描述符，它包含一个指向数组的指针，版本的长度，还有它的容量。&lt;/p></description></item><item><title>Golang 内存分配 - stack and heap</title><link>https://colynn.github.io/2020-07-16-go-memory-allocation/</link><pubDate>Wed, 29 Apr 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-07-16-go-memory-allocation/</guid><description>&lt;h2>&lt;/h2>
&lt;p>&lt;a href="https://golang.org/doc/faq#stack_or_heap">https://golang.org/doc/faq#stack_or_heap&lt;/a>&lt;/p>
&lt;h2 id="stack-and-pointers">stack and pointers&lt;/h2>
&lt;p>我不能解释地像 &lt;a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html">William Kennedy&lt;/a>一样优秀，那就让我来做一个汇总.&lt;/p>
&lt;p>一个变量可以被分配在 &lt;code>heap&lt;/code>或是&lt;code>stack&lt;/code>:&lt;/p>
&lt;ol>
&lt;li>The stack contains the &lt;strong>ongoing&lt;/strong> variables for a given goroutine. Once a function returned, the variables are popped from the stack.&lt;/li>
&lt;li>The heap contains the shared variables (global variables, etc.), and anything on the heap is maaged by the Garbage Collector.&lt;/li>
&lt;/ol>
&lt;p>简而言之，当你需要&lt;code>Sharing&lt;/code>变量，可以使用指针；&lt;/p></description></item><item><title>kubernetes-网络组件-flannel-calico</title><link>https://colynn.github.io/2020-04-10-kubernetes-networking-flannel-calico/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-04-10-kubernetes-networking-flannel-calico/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>网络是kubernetes核心组件， 但是理解它具体是怎样工作却有一定挑战性，主要有4个不同的网络问题要解决：&lt;/p>
&lt;ol>
&lt;li>高度耦合的容器到容器通信：这可以通过&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/">pods&lt;/a>和localhost通信解决。&lt;/li>
&lt;li>Pod与Pod之间的通信；&lt;/li>
&lt;li>Pod与Service间的通信, &lt;a href="https://kubernetes.io/docs/concepts/services-networking/service/">services&lt;/a>；&lt;/li>
&lt;li>外部和 Service间的通信，&lt;a href="https://kubernetes.io/docs/concepts/services-networking/service/">services&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>无论是哪种网络插件，kubernets都要求其满足如下的基础要求。&lt;/p></description></item><item><title>VXLAN是什么及如何在容器间通信</title><link>https://colynn.github.io/2020-04-02-vxlan-is-what/</link><pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-04-02-vxlan-is-what/</guid><description>&lt;h2 id="引言">引言&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>服务器虚拟化对于物理网络基础设施提出了更高的要求，一个物理服务器多个VMs并且每一个vm归有一个自己的Meida Access Control(MAC)地址. 在交换式以太网中为了应对在成百上千的VMs中可能存在的通信连接， 需要较大的MAC地址表。&lt;/p></description></item><item><title>如何让你的 Go 代码更规范 - 辅助工具/项目结构/代码规范</title><link>https://colynn.github.io/2020-03-29-golang-101/</link><pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-03-29-golang-101/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>应云而生的go语言，给我们带来了很多的不错的特性，但是如何让go代码更规范，更优雅，期望可以给你些许帮助。&lt;/p>
&lt;p>作者对于golang也是在不断学习中，文章章节主要基于&lt;a href="blog.golang.org">golang官方博客&lt;/a>、社区的收集及思考，如有不妥可以文末留言，期望您的斧正, 此文也会不断完善。&lt;/p></description></item><item><title>如何创建自己的github站点 - 站点模板选择/gittalk评论组件</title><link>https://colynn.github.io/2020-03-25-create-custom-github-website/</link><pubDate>Wed, 25 Mar 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-03-25-create-custom-github-website/</guid><description>&lt;h2 id="站点模板">站点模板&lt;/h2>
&lt;p>你可以根据&lt;a href="https://jekyllrb.com/docs/themes/">jekyllr themes&lt;/a>选择自己喜欢的模板， 或是创建自己的主题并可以让更多人使用它。&lt;/p>
&lt;h2 id="评论组件">评论组件&lt;/h2>
&lt;p>大多模板已经支持一些评论组件，&lt;code>disqus&lt;/code>/&lt;code>staticman&lt;/code>等，但是考虑到国内的网络环境，就接入了&lt;a href="https://github.com/gittalk">Gittalk&lt;/a>这个评论组件。&lt;/p></description></item><item><title>云原生距离我们有多远</title><link>https://colynn.github.io/2020-03-10-cloud-native-howfarawayfromus/</link><pubDate>Tue, 10 Mar 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-03-10-cloud-native-howfarawayfromus/</guid><description>&lt;h2 id="目录">目录&lt;/h2>
&lt;ol>
&lt;li>何为云原生&lt;/li>
&lt;li>云原生-容器编排kubernetes&lt;/li>
&lt;li>云原生-DevOps方案&lt;/li>
&lt;li>结论&lt;/li>
&lt;/ol>
&lt;h2 id="引言">引言&lt;/h2>
&lt;p>现在越来越多的企业上云，用云，但云原生离我们真的又有多远呢，期望本篇可以让你有些收获, 如果有不妥的地方，期望大家后台留言，共同交流。&lt;/p></description></item><item><title>Using Makefile for Go - Go语言项目如何正确使用Makefile</title><link>https://colynn.github.io/2020-03-03-using_makefile/</link><pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-03-03-using_makefile/</guid><description>&lt;p>我们一直在用Go语言编写的HackerRank项目中的一个项目使用&lt;code>make&lt;/code>作为构建工具，并且效果良好。在这篇文章中，我将指出我们使用的&lt;code>GNU Make&lt;/code>的一些功能和复杂性，这些功能和复杂性最终提高了我们团队成员的整体生产力。&lt;/p></description></item><item><title>tcpdump 介绍</title><link>https://colynn.github.io/2020-02-10-tcpdump/</link><pubDate>Mon, 10 Feb 2020 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-02-10-tcpdump/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>&lt;code>tcpdump&lt;/code>是一个命令行包分析工具，很像 wireshark, 你可以使用&lt;code>tcpdump&lt;/code>抓包、分析包、连接问题的 troubleshoot，和查找网络层上潜在的安全问题。&lt;/p></description></item><item><title>搭建npm私有镜像仓库</title><link>https://colynn.github.io/2019-11-29-npm_private_registry-setup/</link><pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-11-29-npm_private_registry-setup/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>当你的研发团队越来越大，或是你无法忍受node超慢的构建时你可以考虑继续读下去，给大家推荐一个基于&lt;a href="https://verdaccio.org/docs/en/what-is-verdaccio">Verdaccio&lt;/a>相对较完整的解决方案。&lt;/p>
&lt;p>由于环境的原因，我们直接去 &lt;code>npmjs.org&lt;/code> 下载就不要考虑了，可以将&lt;code>npm config set registry=https://registry.npm.taobao.org&lt;/code> 可以缓解一部分, 但是如果你有些自己公司定制的npm包如何在公司内分享呢，这个时候你就需要一个npm私服了.&lt;/p></description></item><item><title>Beego In Use</title><link>https://colynn.github.io/2020-03-03-beego_using/</link><pubDate>Fri, 15 Nov 2019 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2020-03-03-beego_using/</guid><description>&lt;h2 id="时区问题">时区问题&lt;/h2>
&lt;p>ORM 默认使用 time.Local 本地时区&lt;/p>
&lt;p>作用于 ORM 自动创建的时间
从数据库中取回的时间转换成 ORM 本地时间
如果需要的话，你也可以进行更改&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-conf" data-lang="conf">// 设置为 UTC 时间
orm.DefaultTimeLoc = time.UTC
&lt;/code>&lt;/pre>&lt;p>ORM 在进行 RegisterDataBase 的同时，会获取数据库使用的时区，然后在 time.Time 类型存取时做相应转换，以匹配时间系统，从而保证时间不会出错。&lt;/p></description></item><item><title>Kubernetes CI/CD 基于开源组件的实践</title><link>https://colynn.github.io/2019-10-22-kubernetes-ci-cd/</link><pubDate>Tue, 22 Oct 2019 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-10-22-kubernetes-ci-cd/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>应对敏捷开发的需求，对CI(持续集成))/CD（持续交付）的提出了更高的标准，今天来讨论下，如何基于开源组件（gitlab/jenkins/harbor/kubernetes）使用CI/CD，赋能团队的开发、运维。&lt;/p></description></item><item><title>VSCode 开发环境设置(go python)</title><link>https://colynn.github.io/2019-09-26-vscode_env_setting/</link><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-09-26-vscode_env_setting/</guid><description>&lt;h1 id="运行环境">运行环境&lt;/h1>
&lt;ul>
&lt;li>Mac OS 10.13.6&lt;/li>
&lt;li>VS code 1.31.1&lt;/li>
&lt;/ul>
&lt;h1 id="快捷键">快捷键&lt;/h1>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/5203608/89495603-34b84780-d7eb-11ea-94b5-d48d3480b679.png" alt="image">&lt;/p>
&lt;h2 id="解读">解读&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>General&lt;/p>
&lt;ul>
&lt;li>Command + Shift + p, F1 显示命令面板&lt;/li>
&lt;li>Command + p 快速打开&lt;/li>
&lt;li>Command + Shite + N 新建vscode 窗口&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Integrated Terminal&lt;/p>
&lt;ul>
&lt;li>Ctrl + ` 显示或隐藏集成终端；&lt;/li>
&lt;li>Ctrl + Shift + ` 新建终端；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>navigation&lt;/p></description></item><item><title>Kubespary 部署 Kubernetes 1.15.3 版本</title><link>https://colynn.github.io/2019-09-15-kubespray-deploy-k8s/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-09-15-kubespray-deploy-k8s/</guid><description>&lt;h2 id="前置条件">前置条件&lt;/h2>
&lt;ol>
&lt;li>熟悉linux基本命令&lt;/li>
&lt;li>了解k8s基本概念&lt;/li>
&lt;li>K8s master推荐配置&lt;/li>
&lt;/ol>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>节点数量&lt;/th>
 &lt;th>推荐配置（vCPU/Memory/磁盘）&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>1-5 nodes&lt;/td>
 &lt;td>1C/4G/4G&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>6-10 nodes&lt;/td>
 &lt;td>2C/8G/32G&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>11-100 nodes&lt;/td>
 &lt;td>4C/16G/80G&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>101-250 nodes&lt;/td>
 &lt;td>8C/32G/160G&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>251-500 nodes&lt;/td>
 &lt;td>16C/32G/200G&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>大于500 nodes&lt;/td>
 &lt;td>32C/64G/200G&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="安装环境">安装环境&lt;/h2>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>名称&lt;/th>
 &lt;th>内网IP&lt;/th>
 &lt;th>配置&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>node0&lt;/td>
 &lt;td>10.0.0.182&lt;/td>
 &lt;td>2c*4G&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>node1&lt;/td>
 &lt;td>10.0.0.183&lt;/td>
 &lt;td>2c*4G&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="集群安装步骤">集群安装步骤&lt;/h2>
&lt;h3 id="1-设置master与node1间的免密登录">1. 设置master与node1间的免密登录&lt;/h3>
&lt;p>由于kubespray是依赖于ansible，ansible通过ssh协议进行主机之间的访问，所以部署之前需要设置主机之间免密登录，步骤如下：&lt;/p></description></item><item><title>Go Mod 包管理 &amp; gRPC、Protobuf扫盲</title><link>https://colynn.github.io/2019-08-15-introducing_go_mod/</link><pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-08-15-introducing_go_mod/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>In Go 1.11, a new tool has arrived. It&amp;rsquo;s called go mod. For those who don&amp;rsquo;t know what is that, I&amp;rsquo;ll tell you about it.&lt;/p>
&lt;p>One of the purposes of this tool is to get rid of &lt;code>$GOPATH&lt;/code>, so you can git clone a Golang repository anywhere and work on it without worrying about $GOPATH at all. There are other purposes of course, such as simpler versioning and usage, but I think the RIP &lt;code>$GOPATH&lt;/code> is the most notable.&lt;/p></description></item><item><title>python 语法汇总</title><link>https://colynn.github.io/2019-07-26-basic_knowledge_summarizing/</link><pubDate>Fri, 26 Jul 2019 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-07-26-basic_knowledge_summarizing/</guid><description>&lt;h3 id="列表与元组的区别">列表与元组的区别；&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>语法差异：声名方式不同&lt;/strong> 第一个不同点是元组的声明使用小括号，而列表使用方括号，当声明只有一个元素的元组时，需要在这个元素的后面添加英文逗号；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>不可修改类型&lt;/strong> 第二个不同点是元组声明和赋值后，不能像列表一样添加、删除和修改元素，也就是说元组在程序运行过程中不能被修改,无法复制。&lt;/p></description></item><item><title>Go 语法汇总 - Block</title><link>https://colynn.github.io/2019-12-31-go_basic_knowledge_summarizing/</link><pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-12-31-go_basic_knowledge_summarizing/</guid><description>&lt;h2 id="变量声明">变量声明&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>指定变量类型，如果没有初始化，则变量默认为零值;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">import&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">func&lt;/span> &lt;span style="color:#06b;font-weight:bold">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#888">// 声明一个变量并初始化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">var&lt;/span> a = &lt;span style="background-color:#fff0f0">&amp;#34;RUNOOB&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06b;font-weight:bold">Println&lt;/span>(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#888">// 没有初始化就为零值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">var&lt;/span> b &lt;span style="color:#339;font-weight:bold">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06b;font-weight:bold">Println&lt;/span>(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#888">// bool 零值为 false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">var&lt;/span> c &lt;span style="color:#339;font-weight:bold">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06b;font-weight:bold">Println&lt;/span>(c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>根据值自行判定变量类型&lt;/p></description></item><item><title>Mac-PHP环境准备</title><link>https://colynn.github.io/2019-03-05-mac_prepare_php_env/</link><pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-03-05-mac_prepare_php_env/</guid><description>&lt;h3 id="前置条件">前置条件&lt;/h3>
&lt;ol>
&lt;li>Mac OS 10.13.6&lt;/li>
&lt;li>安装Homebrew 包管理工具；&lt;/li>
&lt;li>安装 autoconf (解决xdebug编译依赖问题)&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>说明&lt;/strong>: brew 全称Homebrew, 是Mac OSX上的软件包管理工具&lt;/p>
&lt;p>&lt;em>注&lt;/em>: PECL（The PHP Extension Community Library）是 PHP 扩展的存储库，为 PHP所有的扩展提供提供托管和下载服务。
通过 PEAR的 Package Manager 的安装管理方式，可以对PECL扩展进行下载和安装&lt;/p></description></item><item><title>Charles 抓包（http/https）</title><link>https://colynn.github.io/2019-02-13-charles_capture_package/</link><pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-02-13-charles_capture_package/</guid><description>&lt;h3 id="运行环境">运行环境&lt;/h3>
&lt;ul>
&lt;li>Mac os 10.13.6&lt;/li>
&lt;li>Ios 12.1.2(16C101)&lt;/li>
&lt;/ul>
&lt;h3 id="下载安装">下载安装&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.charlesproxy.com/download/">官网下载&lt;/a>&lt;/li>
&lt;li>&lt;em>注&lt;/em>: 破解版麻请自行搜索下载&lt;/li>
&lt;/ul>
&lt;h3 id="配置">配置&lt;/h3>
&lt;ol>
&lt;li>Proxy -&amp;gt; Proxy Settings (根据需要调整配置，保存)；&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>注&lt;/strong>: 如果仅需要抓取http包，请略过后续步骤。&lt;/p>
&lt;ol start="2">
&lt;li>Proxy -&amp;gt; SSL Proxying Settings&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/5203608/89494735-67614080-d7e9-11ea-877e-a642bec7ed66.png" alt="image">&lt;/p>
&lt;ol start="3">
&lt;li>电脑端安装证书 Help -&amp;gt; SSL Proxying -&amp;gt; Install Charles Root Certificate，并将证书标记为始终信任&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/5203608/89494759-75af5c80-d7e9-11ea-94c2-d711e086ecd5.png" alt="image">&lt;/p></description></item><item><title>安装 MiniKube</title><link>https://colynn.github.io/2019-02-13-install_minikube/</link><pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-02-13-install_minikube/</guid><description>&lt;h3 id="前置条件">前置条件&lt;/h3>
&lt;ul>
&lt;li>mac os 10.13.6&lt;/li>
&lt;li>Virtual Box&lt;/li>
&lt;/ul>
&lt;h4 id="确认环境需求">确认环境需求&lt;/h4>
&lt;p>Minikube 要求在 BIOS 中启用 VT-x / AMD-v 虚拟化， 要检查这是否在OSX / macOS上运行，请执行以下操作：&lt;/p>
&lt;pre tabindex="0">&lt;code>sysctl -a | grep machdep.cpu.features | grep VMX
&lt;/code>&lt;/pre>&lt;p>如果有输出，那你很棒棒！&lt;/p>
&lt;h4 id="配置brew-镜像源">配置Brew 镜像源&lt;/h4>
&lt;pre tabindex="0">&lt;code>cd &amp;#34;$(brew --repo)&amp;#34;
git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git

cd &amp;#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;#34;
git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git
&lt;/code>&lt;/pre>&lt;h3 id="相关软件安装">相关软件安装&lt;/h3>
&lt;ul>
&lt;li>kubectl&lt;/li>
&lt;li>docker (for Mac)&lt;/li>
&lt;li>minikube&lt;/li>
&lt;li>virtualbox&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>安装kubectl&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>$ brew update &amp;amp;&amp;amp; brew install kubectl
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>minikube(可以直接通过brew来安装)&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.30.0/minikube-darwin-amd64 &amp;amp;&amp;amp; chmod +x minikube &amp;amp;&amp;amp; sudo mv minikube /usr/local/bin/
&lt;/code>&lt;/pre>&lt;p>&lt;em>注：&lt;/em> 可以从这里获得更多的版本选择 &lt;a href="https://github.com/kubernetes/minikube/releases">kuernetes minikube releases&lt;/a>&lt;/p></description></item><item><title>Shell命令备注手册</title><link>https://colynn.github.io/2019-01-02-shell-notes/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-01-02-shell-notes/</guid><description>&lt;h2 id="sed">Sed&lt;/h2>
&lt;h3 id="直接编辑文件">直接编辑文件&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>sed -i &lt;span style="background-color:#fff0f0">&amp;#39;s/abc/xxx/g&amp;#39;&lt;/span> file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sed -i &lt;span style="background-color:#fff0f0">&amp;#39;/$xxx.*$/d&amp;#39;&lt;/span> file
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>注&lt;/strong>: 仅仅工作在linux类型的主机上&lt;/p></description></item><item><title>运维常用命令备注手册</title><link>https://colynn.github.io/2019-01-01-ops-notes/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-01-01-ops-notes/</guid><description>&lt;h2 id="git">Git&lt;/h2>
&lt;h3 id="fork出来的仓库同步upstream">fork出来的仓库同步upstream&lt;/h3>
&lt;ol>
&lt;li>在 fork 的代码库中添加上游代码库的 remote 源&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git remote add upstream git@github.com:789/456.git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>获取原始仓库分支和对应的提交&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git fetch upstream
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>在本地实现与upstream的同步&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git rebase upstream/master
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>推送自己的本地仓库到自己的远程仓库&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git push
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="push-tags-to-remote">Push tags to remote&lt;/h3>
&lt;ul>
&lt;li>&lt;code>git push --tags &amp;lt;repo-name&amp;gt;&lt;/code> All refs under refs/tags are pushed, in addition to refspecs explicitly listed on the command line.&lt;/li>
&lt;/ul>
&lt;h3 id="delete-remote-tagsbranch">Delete remote tags/branch&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888"># more expressively, use the --delete option (or -d if your git version is older than 1.8.0)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push --delete origin tagname
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>or&lt;/p></description></item><item><title>JS语法知识汇总</title><link>https://colynn.github.io/2019-08-19-js_base_summaring/</link><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-08-19-js_base_summaring/</guid><description>&lt;h2 id="数据类型">数据类型&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">var&lt;/span> length &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">7&lt;/span>; &lt;span style="color:#888">// 数字
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#080;font-weight:bold">var&lt;/span> lastName &lt;span style="color:#333">=&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#34;Gates&amp;#34;&lt;/span>; &lt;span style="color:#888">// 字符串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#080;font-weight:bold">var&lt;/span> cars &lt;span style="color:#333">=&lt;/span> [&lt;span style="background-color:#fff0f0">&amp;#34;Porsche&amp;#34;&lt;/span>, &lt;span style="background-color:#fff0f0">&amp;#34;Volvo&amp;#34;&lt;/span>, &lt;span style="background-color:#fff0f0">&amp;#34;BMW&amp;#34;&lt;/span>]; &lt;span style="color:#888">// 数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#080;font-weight:bold">var&lt;/span> x &lt;span style="color:#333">=&lt;/span> {firstName&lt;span style="color:#333">:&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;Bill&amp;#34;&lt;/span>, lastName&lt;span style="color:#333">:&lt;/span>&lt;span style="background-color:#fff0f0">&amp;#34;Gates&amp;#34;&lt;/span>}; &lt;span style="color:#888">// 对象 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#080;font-weight:bold">var&lt;/span> x &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#080;font-weight:bold">true&lt;/span>; &lt;span style="color:#888">// 布尔值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#080;font-weight:bold">var&lt;/span> y &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#080;font-weight:bold">false&lt;/span>; &lt;span style="color:#888">//布尔值
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="数组-some">数组 some&lt;/h3>
&lt;p>The &lt;code>some()&lt;/code> method checks if any of the elements in an array pass a test (provided as a function).&lt;/p>
&lt;p>The &lt;code>some()&lt;/code> method executes the function once for each element present in the array:&lt;/p>
&lt;p>If it finds an array element where the function returns a true value, some() returns &lt;code>true&lt;/code> (and does not check the remaining values)
Otherwise it returns &lt;code>false&lt;/code>
&lt;strong>Note:&lt;/strong> some() does not execute the function for array elements without values.&lt;/p></description></item><item><title>PyCharm 开发环境设置</title><link>https://colynn.github.io/2019-09-26-pycharm_env_setting/</link><pubDate>Thu, 15 Mar 2018 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-09-26-pycharm_env_setting/</guid><description>&lt;h2 id="运行环境">运行环境&lt;/h2>
&lt;ul>
&lt;li>Mac OS 10.13.6&lt;/li>
&lt;li>PyCharm 2018.1&lt;/li>
&lt;/ul>
&lt;h3 id="确认代码检查规范">确认代码检查规范&lt;/h3>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/5203608/89404105-059ec900-d74c-11ea-8998-3d71a7cb8cdc.png" alt="image">&lt;/p>
&lt;h3 id="当前文件-快速格式化代码--option--command--l">当前文件-快速格式化代码 (option + command + l)&lt;/h3>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/5203608/89410539-7a770080-d756-11ea-9b42-b955c02185a9.png" alt="image">&lt;/p>
&lt;h3 id="代码注释方式---支持-google-restructuredtext-等">代码注释方式 - 支持 google/ reStructuredText 等&lt;/h3>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/5203608/89410596-97abcf00-d756-11ea-9348-e4a82cb59521.png" alt="image">&lt;/p>
&lt;h3 id="定义-文件代码模板">定义-文件/代码模板&lt;/h3>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/5203608/89410646-b4480700-d756-11ea-8fec-a49d70766852.png" alt="image">&lt;/p></description></item><item><title>小程序实践归档</title><link>https://colynn.github.io/2019-08-19-mp_login_recommend_practice/</link><pubDate>Thu, 15 Mar 2018 00:00:00 +0000</pubDate><guid>https://colynn.github.io/2019-08-19-mp_login_recommend_practice/</guid><description>&lt;h3 id="登录-推荐实践">登录-推荐实践&lt;/h3>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/5203608/89495221-67157500-d7ea-11ea-8333-f55edfb8b873.png" alt="image">&lt;/p>
&lt;h3 id="登录-实现原则">登录-实现原则&lt;/h3>
&lt;ul>
&lt;li>小程序与开发服务器端通过 3rd_session（第三方session）【即自定义登录状态】来实现通信，微信官方也不建议直接通过openid/session_key来通信；&lt;/li>
&lt;/ul>
&lt;p>&lt;em>原因&lt;/em>： openid是微信用户的唯一标识，直接用于传参通信的话，会存在被第三方组织截获的风险，进而用于其他用途，
如本地模拟请求，使用截获的openid作为传参，从而就可以伪装成相应的人。&lt;/p></description></item></channel></rss>