<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Colynn.Liu"><link rel=prev href=https://colynn.github.io/2020-02-10-tcpdump/><link rel=next href=https://colynn.github.io/2020-03-10-cloud-native-howfarawayfromus/><link rel=canonical href=https://colynn.github.io/2020-03-03-using_makefile/><link rel=apple-touch-icon sizes=180x180 href=/img/favicon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Using Makefile for Go - Go语言项目如何正确使用Makefile | Colynn.Liu</title><meta name=title content="Using Makefile for Go - Go语言项目如何正确使用Makefile | Colynn.Liu"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/colynn.github.io\/"},"articleSection":"posts","name":"Using Makefile for Go - Go语言项目如何正确使用Makefile","headline":"Using Makefile for Go - Go语言项目如何正确使用Makefile","description":"我们一直在用Go语言编写的HackerRank项目中的一个项目使用make作为构建工具，并且效果良好。在这篇文章中，我将指出我们使用的GNU","inLanguage":"zh-CN","author":"Colynn.Liu","creator":"Colynn.Liu","publisher":"Colynn.Liu","accountablePerson":"Colynn.Liu","copyrightHolder":"Colynn.Liu","copyrightYear":"2020","datePublished":"2020-03-03 00:00:00 \u002b0000 UTC","dateModified":"2020-03-03 00:00:00 \u002b0000 UTC","url":"https:\/\/colynn.github.io\/2020-03-03-using_makefile\/","wordCount":"3184","keywords":["go","Colynn.Liu"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">Using Makefile for Go - Go语言项目如何正确使用Makefile</h1><div class=post-meta>Written by <a itemprop=name href=https://colynn.github.io/ rel=author>Colynn.Liu</a> with ♥
<span class=post-time>on <time datetime=2020-03-03 itemprop=datePublished>March 3, 2020</time></span>
<span class=post-time>- last modified <time datetime=2020-03-03 itemprop=datePublished>March 3, 2020</time></span></div><div class=post-tags><section><span class=tag><a href=https://colynn.github.io/tags/go/><i class="iconfont icon-tag"></i>go</a></span></section><section><i class="iconfont icon-folder"></i><span class=post-category><a href=https://colynn.github.io/categories/%E6%95%99%E7%A8%8B/>教程</a></span></section></div></header><div class=post-content><p>我们一直在用Go语言编写的HackerRank项目中的一个项目使用<code>make</code>作为构建工具，并且效果良好。在这篇文章中，我将指出我们使用的<code>GNU Make</code>的一些功能和复杂性，这些功能和复杂性最终提高了我们团队成员的整体生产力。</p><h2 id=前言>前言</h2><p><code>make</code> 是一个简单的工具，它可以检测大型项目的哪个部分需要重新编译和执行用户定义的命令编译或是其他需要的操作。它也广泛用作构建工具， 您可以在其中指定要运行的一组命令，这些命令本来是用来在命令行上编写的，通常是重复多次执行。下面是本文其余部分的主要内容。</p><p>为了这篇文章的目的，我们假设我们正在从事GO项目<code>stringifier</code> , 而且将会编写一个Makefile, 也称为Makefile。</p><h2 id=build-and-run>Build and Run</h2><p>Go程序的这两个指令使用的相当频繁, 所以添加这些目录至我们的<code>Makefile</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#06b;font-weight:700>build</span><span style=color:#333>:</span> 
    go build -o stringifier main.go

<span style=color:#06b;font-weight:700>run</span><span style=color:#333>:</span>
    go run -race main.go
</code></pre></div><p>我在运行命令中添加了<code>-race</code>标志，方便它在运行时在Go代码中检测到<code>race</code>情况。</p><h2 id=cleaning-and-drying>Cleaning and DRYing</h2><p>构建二进制文件并运行应用程序后，一切正常, 确保我们在执行其他任何操作之前先清理二进制文件。我们更新<code>Makefile</code>应该看起来像这样：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#06b;font-weight:700>build</span><span style=color:#333>:</span>
	go build -o stringifier main.go

<span style=color:#06b;font-weight:700>run</span><span style=color:#333>:</span>
	go run -race main.go

<span style=color:#06b;font-weight:700>clean</span><span style=color:#333>:</span>
	go clean

</code></pre></div><p>我们有两点可以改进，</p><ol><li>我们明确地重用了我们的应用程序名, 很自然我们的应用程序名称将在整个<code>Makefile</code>中的许多地方使用。</li><li>每次构建应用之前，我们需要先执行<code>clean</code>的规则。</li></ol><p>改进后的<code>Makefile</code></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#963>APP</span><span style=color:#333>=</span>stringifier

<span style=color:#06b;font-weight:700>build</span><span style=color:#333>:</span> clean
	go build -o <span style=background-color:#eee>${</span><span style=color:#963>APP</span><span style=background-color:#eee>}</span> main.go

<span style=color:#06b;font-weight:700>run</span><span style=color:#333>:</span>
	go run -race main.go

<span style=color:#06b;font-weight:700>clean</span><span style=color:#333>:</span>
	go clean

</code></pre></div><p><strong>更新</strong>: 这个例子之前使用的<code>rm -r ${APP}</code>， 但是感谢讲者的建议，现在使用<code>go clean</code>。</p><p>在顶部定义<code>Makefile</code>变量，当您调用<code>make</code>命令时make将自动引用它们，这样<code>Makefile</code>看起来就更整洁、规范了。</p><h2 id=phony-targets>PHONY targets</h2><p><strong>默认情况下</strong>，如果一个前置条件或是目录文件已更改，<code>make</code>将执行规则。但是由于我们不依赖于<code>make</code>来检测文件更改的能力，因此我们会遇到潜在的麻烦。</p><p>假设我们的项目目录中有一个名为build的文件, 在这个场景下，当你执行<code>make build</code>, make一定会检查文件build的更改，由于没有前置条件，因此将始终将<code>build</code>文件视为最新的，并且不会执行其规则定义的操作。</p><p>为了避免这个问题，你需要先知道<code>.PHONY</code> 特殊目录(target)是什么意思：特殊目标<code>.PHONY</code>的先决条件被视为phony目标（targets)。 当需要运行时，make会无条件运行其规则，而不管该名称的文件是否存在或其最后修改时间是多少。</p><p>所以，你可以通过将目标（target）指定为特殊目标<code>.PHONY</code>的先决条件，将目标指定为<code>.PHONY</code>。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#963>APP</span><span style=color:#333>=</span>stringifier


<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> build
<span style=color:#06b;font-weight:700>build</span><span style=color:#333>:</span> clean
	go build -o <span style=background-color:#eee>${</span><span style=color:#963>APP</span><span style=background-color:#eee>}</span> main.go

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> run
<span style=color:#06b;font-weight:700>run</span><span style=color:#333>:</span>
	go run -race main.go

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> clean
<span style=color:#06b;font-weight:700>clean</span><span style=color:#333>:</span>
	go clean
</code></pre></div><p>现在你已将上述所有的<code>targets</code>指定为<code>phony</code>, 每次你调用任何<code>phony</code>目标（target) 时，make将会执行相应的规则。你还可以一次将所有要指定为<code>phony</code>的目标指定为:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> build clean run
</code></pre></div><p>但是对于非常大的Makefile，不建议这样做因为这可能导致歧义和无法读取。因此，首选方法是在规则定义之前显式设置<code>phony</code>目标（target）。</p><h2 id=recursive-make-targets>Recursive Make targets</h2><p>现在让我们假设我们在项目中使用的根目录中还有另一个模块<code>tokenizer</code>。现在我们的目录结构是这样的：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>~/programming/stringifier
.
├── main.go
├── Makefile
└── tokenizer/
      ├── main.go
      └── Makefile
</code></pre></div><p>很自然，某些时候我们也想<code>build</code>和<code>test</code>我们的<code>tokenizer</code>模块。由于它是一个独立的模块也可能是一个独立的项目，在它的目录有如下内容的一个<code>Makefile</code>是很有必要的：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#888># ~/programming/stringifier/tokenizer/Makefile
</span><span style=color:#888></span>
<span style=color:#963>APP</span><span style=color:#333>=</span>tokenizer

<span style=color:#06b;font-weight:700>build</span><span style=color:#333>:</span>
	go build -o <span style=background-color:#eee>${</span><span style=color:#963>APP</span><span style=background-color:#eee>}</span> main.go
</code></pre></div><p>现在只要您在<code>stringifier</code>项目的根目录中并且想要构建<code>tokenizer</code>应用程序，你不会想使用诸如<code>cd tokenizer && make build && cd - </code>这样的易受攻击的命令行技巧，而具体的<code>Makefiles</code>的规则写在子目录中的方式。幸运的是，<code>make</code>可以帮助你解决这个问题。你可以使用<code>-C</code>标志和特殊的<code>${NAME}</code>变量在其他目录中调用<code>make targets</code>。下面是<code>stringifies</code>项目最初的Makefile:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#888># ~/programming/stringifier/Makefile
</span><span style=color:#888></span>
<span style=color:#963>APP</span><span style=color:#333>=</span>stringifier


<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> build
<span style=color:#06b;font-weight:700>build</span><span style=color:#333>:</span> clean
	go build -o <span style=background-color:#eee>${</span><span style=color:#963>APP</span><span style=background-color:#eee>}</span> main.go

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> run
<span style=color:#06b;font-weight:700>run</span><span style=color:#333>:</span>
	go run -race main.go

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> clean
<span style=color:#06b;font-weight:700>clean</span><span style=color:#333>:</span>
	go clean

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> build-tokenizer
<span style=color:#06b;font-weight:700>build-tokenizer</span><span style=color:#333>:</span>
	<span style=background-color:#eee>${</span><span style=color:#963>MAKE</span><span style=background-color:#eee>}</span> -C tokenizer build
</code></pre></div><p>现在只要你运行<code>make build-tokenizer</code>，<code>make</code>都将为您处理目录切换，并以更加可读和健壮的方式为您调用正确目录中的正确目标</p><h2 id=targets-for-docker-commands>Targets for Docker commands</h2><p>现在您希望对应用程序进行容器化，然后为方便起见编写make目标，这是完全可以理解的。</p><p>你为docker命令定义了如下规则：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> docker-build
<span style=color:#06b;font-weight:700>docker-build</span><span style=color:#333>:</span> build
	docker build -t stringifier .
	docker tag stringifier stringifier:tag

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> docker-push
<span style=color:#06b;font-weight:700>docker-push</span><span style=color:#333>:</span> docker-build
	docker push gcr.io/stringifier/stringifier-staging/stringifier:tag
</code></pre></div><p>docker命令基本满足需要，但是还有改善的空间，</p><ul><li>对于新手，你可以再次重用你的<code>${APP}</code>变量。</li><li>接下来，您想要更灵活并确保可以轻松控制将映像推送到哪里，无论是您的私人镜像仓库还是其他地方。</li><li>然后，您希望能够根据用户在命令行上的某些输入将镜像（image）分别推送到与预生产和生产环境有关的两个单独的镜像仓库中。</li><li>最后，像一个理智的开发人员一样，您想使用当前的git commit sha标记您的镜像（image）。 让我们基于这些问题重新修改下<code>Makefile</code>：</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#963>APP</span><span style=color:#333>?=</span>application
<span style=color:#963>REGISTRY</span><span style=color:#333>?=</span>gcr.io/images
<span style=color:#963>COMMIT_SHA</span><span style=color:#333>=</span><span style=color:#080;font-weight:700>$(</span>shell git rev-parse --short HEAD<span style=color:#080;font-weight:700>)</span>

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> docker-build
<span style=color:#06b;font-weight:700>docker-build</span><span style=color:#333>:</span> build
	docker build -t <span style=background-color:#eee>${</span><span style=color:#963>APP</span><span style=background-color:#eee>}</span> .
	docker tag <span style=background-color:#eee>${</span><span style=color:#963>APP</span><span style=background-color:#eee>}</span> <span style=background-color:#eee>${</span><span style=color:#963>APP</span><span style=background-color:#eee>}</span>:<span style=background-color:#eee>${</span><span style=color:#963>COMMIT_SHA</span><span style=background-color:#eee>}</span>

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> docker-push
<span style=color:#06b;font-weight:700>docker-push</span><span style=color:#333>:</span> check-environment docker-build
	docker push <span style=background-color:#eee>${</span><span style=color:#963>REGISTRY</span><span style=background-color:#eee>}</span>/<span style=background-color:#eee>${</span><span style=color:#963>ENV</span><span style=background-color:#eee>}</span>/<span style=background-color:#eee>${</span><span style=color:#963>APP</span><span style=background-color:#eee>}</span>:<span style=background-color:#eee>${</span><span style=color:#963>COMMIT_SHA</span><span style=background-color:#eee>}</span>

<span style=color:#06b;font-weight:700>check-environment</span><span style=color:#333>:</span>
<span style=color:red;background-color:#faa>ifndef</span> <span style=color:red;background-color:#faa>ENV</span>
    <span style=color:#080;font-weight:700>$(</span><span style=color:#963>error</span> <span style=color:#963>ENV</span> <span style=color:#963>not</span> <span style=color:#963>set</span>, <span style=color:#963>allowed</span> <span style=color:#963>values</span> - `<span style=color:#963>staging</span>` <span style=color:#963>or</span> `<span style=color:#963>production</span>`<span style=color:#080;font-weight:700>)</span>
<span style=color:red;background-color:#faa>endif</span>

</code></pre></div><p>现在，让我们回顾下上面的更改：</p><ul><li>你开始为应用程序名称，镜像名称,提交sha使用变量。</li><li>您使用特殊的shell函数生成了commit sha。 在这种情况下，您运行了git命令，该命令返回了简短的提交sha，并将其分配给变量<code>${COMMIT_SHA}</code>，以便稍后在Makefile中使用。</li><li>您添加了一个新的规则<code>check-environment</code>，该环境使用make条件检查在调用make时是否指定了<code>ENV</code>变量，这有助于区分预生产及生产环境。</li></ul><p><code>check-environment</code>的规则如下：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#06b;font-weight:700>check-environment</span><span style=color:#333>:</span>
<span style=color:red;background-color:#faa>ifndef</span> <span style=color:red;background-color:#faa>ENV</span>
    <span style=color:#080;font-weight:700>$(</span><span style=color:#963>error</span> <span style=color:#963>ENV</span> <span style=color:#963>not</span> <span style=color:#963>set</span>, <span style=color:#963>allowed</span> <span style=color:#963>values</span> - `<span style=color:#963>staging</span>` <span style=color:#963>or</span> `<span style=color:#963>production</span>`<span style=color:#080;font-weight:700>)</span>
<span style=color:red;background-color:#faa>endif</span>
</code></pre></div><p>使用<code>ifndef</code>指令检查变量ENV是否为空值，如果存在，则使用另一个make的提供内置函数，如果出错了，将会在关键字之后抛出具体的错误消息。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ make docker-push
Makefile:33: *** ENV not set, allowed values - <span style=background-color:#fff0f0>`</span>staging<span style=background-color:#fff0f0>`</span> or <span style=background-color:#fff0f0>`</span>production<span style=background-color:#fff0f0>`</span>.  Stop.

$ <span style=color:#963>ENV</span><span style=color:#333>=</span>staging make docker-push
Success
</code></pre></div><p>本质上，您要确保docker-push目标具有安全保障，该保障可检查调用目标的用户是否已为ENV变量指定值。</p><h2 id=help-target>Help target</h2><p>一个新成员加入了该项目并想知道Makefile中所有规则的作用，为帮助它们您可以添加一个新目标(target)，该目标将打印所有目标名称以及它们作用的简短描述:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> build
<span style=color:#888>## build: build the application
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>build</span><span style=color:#333>:</span> clean
    @echo <span style=background-color:#fff0f0>&#34;Building...&#34;</span>
    @go build -o <span style=background-color:#eee>${</span><span style=color:#963>APP</span><span style=background-color:#eee>}</span> main.go

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> run
<span style=color:#888>## run: runs go run main.go
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>run</span><span style=color:#333>:</span>
	go run -race main.go

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> clean
<span style=color:#888>## clean: cleans the binary
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>clean</span><span style=color:#333>:</span>
    @echo <span style=background-color:#fff0f0>&#34;Cleaning&#34;</span>
    @go clean

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> setup
<span style=color:#888>## setup: setup go modules
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>setup</span><span style=color:#333>:</span>
	@go mod init <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>		<span style=color:#333>&amp;&amp;</span> go mod tidy <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>		<span style=color:#333>&amp;&amp;</span> go mod vendor
	
<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> help
<span style=color:#888>## help: prints this help message
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>help</span><span style=color:#333>:</span>
	@echo <span style=background-color:#fff0f0>&#34;Usage: \n&#34;</span>
	@sed -n <span style=background-color:#fff0f0>&#39;s/^##//p&#39;</span> <span style=background-color:#eee>${</span><span style=color:#963>MAKEFILE_LIST</span><span style=background-color:#eee>}</span> | column -t -s <span style=background-color:#fff0f0>&#39;:&#39;</span> |  sed -e <span style=background-color:#fff0f0>&#39;s/^/ /&#39;</span>
</code></pre></div><p>你先注意下最后一条规则，<code>help</code> 在这里，您只是使用一些sed魔术来解析和在命令行上打印。 但是要做到这一点，您必要在每条规则之前写了目标名称和简短描述作为注释。
注意另一个特殊变量$ {MAKEFILE_LIST}，它是您所引用的所有Makefile的列表，在本例中仅是Makefile。</p><p>您会将文件Makefile作为输入传递给sed命令，该命令将解析所有帮助注释并以表格格式将其打印到stdout，以便于阅读。 上一个代码段的<code>help</code>目标的输出如下所示：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ make <span style=color:#007020>help</span>
Usage:
	build             Build the application
	clean             cleans the binary
	run               runs go run main.go
	docker-build      builds docker image
	docker-push       pushes the docker image
	setup             <span style=color:#007020>set</span> up modules
	<span style=color:#007020>help</span>              prints this <span style=color:#007020>help</span> message
</code></pre></div><p>这些消息很有帮助，对于其他人甚至有时对自己都是一个不错的提示。</p><h2 id=conclusion-结论>Conclusion 结论</h2><p>Make是一个简单但可高度配置的工具。 在本文中，您遍历了make提供的许多配置和功能，从而为Go应用程序编写了有效而高效的Makefile。</p><p>下面是完整的Makefile，其中添加了一些琐碎的规则和变量：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#963>GO111MODULES</span><span style=color:#333>=</span>on
<span style=color:#963>APP</span><span style=color:#333>?=</span>stringifier
<span style=color:#963>REGISTRY</span><span style=color:#333>?=</span>gcr.io/images
<span style=color:#963>COMMIT_SHA</span><span style=color:#333>=</span><span style=color:#080;font-weight:700>$(</span>shell git rev-parse --short HEAD<span style=color:#080;font-weight:700>)</span>



<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> build
<span style=color:#888>## build: build the application
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>build</span><span style=color:#333>:</span> clean
    @echo <span style=background-color:#fff0f0>&#34;Building...&#34;</span>
    @go build -o <span style=background-color:#eee>${</span><span style=color:#963>APP</span><span style=background-color:#eee>}</span> main.go

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> run
<span style=color:#888>## run: runs go run main.go
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>run</span><span style=color:#333>:</span>
	go run -race main.go

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> clean
<span style=color:#888>## clean: cleans the binary
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>clean</span><span style=color:#333>:</span>
    @echo <span style=background-color:#fff0f0>&#34;Cleaning&#34;</span>
    @go clean

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> test
<span style=color:#888>## test: runs go test with default values
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>test</span><span style=color:#333>:</span>
	go <span style=color:#007020>test</span> -v -count<span style=color:#333>=</span><span style=color:#60e;font-weight:700>1</span> -race ./...


<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> build-tokenizer
<span style=color:#888>## build-tokenizer: build the tokenizer application
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>build-tokenizer</span><span style=color:#333>:</span>
	<span style=background-color:#eee>${</span><span style=color:#963>MAKE</span><span style=background-color:#eee>}</span> -c tokenizer build

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> setup
<span style=color:#888>## setup: setup go modules
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>setup</span><span style=color:#333>:</span>
	@go mod init <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>		<span style=color:#333>&amp;&amp;</span> go mod tidy <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>		<span style=color:#333>&amp;&amp;</span> go mod vendor
	
<span style=color:#888># helper rule for deployment
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>check-environment</span><span style=color:#333>:</span>
<span style=color:red;background-color:#faa>ifndef</span> <span style=color:red;background-color:#faa>ENV</span>
    <span style=color:#080;font-weight:700>$(</span><span style=color:#963>error</span> <span style=color:#963>ENV</span> <span style=color:#963>not</span> <span style=color:#963>set</span>, <span style=color:#963>allowed</span> <span style=color:#963>values</span> - `<span style=color:#963>staging</span>` <span style=color:#963>or</span> `<span style=color:#963>production</span>`<span style=color:#080;font-weight:700>)</span>
<span style=color:red;background-color:#faa>endif</span>

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> docker-build
<span style=color:#888>## docker-build: builds the stringifier docker image to registry
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>docker-build</span><span style=color:#333>:</span> build
	docker build -t <span style=background-color:#eee>${</span><span style=color:#963>APP</span><span style=background-color:#eee>}</span>:<span style=background-color:#eee>${</span><span style=color:#963>COMMIT_SHA</span><span style=background-color:#eee>}</span> .

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> docker-push
<span style=color:#888>## docker-push: pushes the stringifier docker image to registry
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>docker-push</span><span style=color:#333>:</span> check-environment docker-build
	docker push <span style=background-color:#eee>${</span><span style=color:#963>REGISTRY</span><span style=background-color:#eee>}</span>/<span style=background-color:#eee>${</span><span style=color:#963>ENV</span><span style=background-color:#eee>}</span>/<span style=background-color:#eee>${</span><span style=color:#963>APP</span><span style=background-color:#eee>}</span>:<span style=background-color:#eee>${</span><span style=color:#963>COMMIT_SHA</span><span style=background-color:#eee>}</span>

<span style=color:#06b;font-weight:700>.PHONY</span><span style=color:#333>:</span> help
<span style=color:#888>## help: Prints this help message
</span><span style=color:#888></span><span style=color:#06b;font-weight:700>help</span><span style=color:#333>:</span>
	@echo <span style=background-color:#fff0f0>&#34;Usage: \n&#34;</span>
	@sed -n <span style=background-color:#fff0f0>&#39;s/^##//p&#39;</span> <span style=background-color:#eee>${</span><span style=color:#963>MAKEFILE_LIST</span><span style=background-color:#eee>}</span> | column -t -s <span style=background-color:#fff0f0>&#39;:&#39;</span> |  sed -e <span style=background-color:#fff0f0>&#39;s/^/ /&#39;</span>
</code></pre></div><p>Refer to:</p><ol><li><a href=https://danishpraka.sh/2019/12/07/using-makefiles-for-go.html>https://danishpraka.sh/2019/12/07/using-makefiles-for-go.html</a></li><li><a href=https://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets>https://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets</a></li></ol></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Colynn.Liu</span></p><p class=copyright-item><span>Link:</span>
<a href=https://colynn.github.io/2020-03-03-using_makefile/>https://colynn.github.io/2020-03-03-using_makefile/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://colynn.github.io/tags/go/>#go</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://colynn.github.io/>home</a></span></section></div><div class=post-nav><a href=https://colynn.github.io/2020-02-10-tcpdump/ class=prev rel=prev title="tcpdump 介绍"><i class="iconfont icon-left"></i>&nbsp;tcpdump 介绍</a>
<a href=https://colynn.github.io/2020-03-10-cloud-native-howfarawayfromus/ class=next rel=next title=云原生距离我们有多远>云原生距离我们有多远&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><script src=https://utteranc.es/client.js repo=colynn/blog-comments issue-term=pathname label=utterances theme=github-light crossorigin=anonymous async></script></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2018 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://colynn.github.io/>Colynn.Liu</a> |</span>
<span><a href=https://colynn.github.io/friends>友情链接</a></span></div></footer><script src=/js/vendor_no_gallery.min.js async></script></div></body></html>