<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Colynn.Liu"><meta name=description content="Full-Stack DevOps, Be focused and Practical"><link rel=prev href=https://colynn.github.io/2021-08-12-k8s-operator/><link rel=canonical href=https://colynn.github.io/2022-05-02-docker-volume/><link rel=apple-touch-icon sizes=180x180 href=/img/home-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>理解并正确使用docker volume/bind mount | Colynn.Liu</title><meta name=title content="理解并正确使用docker volume/bind mount | Colynn.Liu"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/colynn.github.io\/"},"articleSection":"posts","name":"理解并正确使用docker volume\/bind mount","headline":"理解并正确使用docker volume\/bind mount","description":"写在前面 默认情况下，在容器内创建的所有文件都存储在一个可写的容器层上(如下图)， 问题 但是这也带来如下的几个问题： 当该容器不再存在时，数据并不","inLanguage":"zh-CN","author":"Colynn.Liu","creator":"Colynn.Liu","publisher":"Colynn.Liu","accountablePerson":"Colynn.Liu","copyrightHolder":"Colynn.Liu","copyrightYear":"2022","datePublished":"2022-05-04 00:00:00 \u002b0000 UTC","dateModified":"2022-05-04 00:00:00 \u002b0000 UTC","url":"https:\/\/colynn.github.io\/2022-05-02-docker-volume\/","wordCount":"1576","keywords":["docker","Colynn.Liu"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/readings/>书单</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/readings/>书单</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">理解并正确使用docker volume/bind mount</h1><div class=post-meta>Written by <a itemprop=name href=https://colynn.github.io/ rel=author>Colynn.Liu</a> with ♥
<span class=post-time>on <time datetime=2022-05-04 itemprop=datePublished>May 4, 2022</time></span>
<span class=post-time>- last modified on <time datetime=2022-05-04 itemprop=datePublished>May 5, 2022</time></span></div><div class=post-tags><section><span class=tag><a href=https://colynn.github.io/tags/docker/><i class="iconfont icon-tag"></i>docker</a></span></section><section></section></div></header><div class=post-content><h2 id=写在前面>写在前面</h2><p>默认情况下，在容器内创建的所有文件都存储在一个可写的容器层上(如下图)，</p><p><img src=https://user-images.githubusercontent.com/5203608/166707397-5e8d89b4-78b9-4813-a67e-c180a083af98.png alt=Image></p><h3 id=问题>问题</h3><p>但是这也带来如下的几个问题：</p><ul><li>当该容器不再存在时，数据并不持久，而且如果另一个进程需要这些数据，就很难将其从容器中取出。</li><li>容器的可写层与容器所运行的主机紧密相连。你不能轻易地把数据移到别的地方。</li><li>写入容器的可写层需要一个存储驱动来管理文件系统。存储驱动提供了一个联合文件系统，使用Linux内核。与使用数据卷直接写在主机文件系统中，这种额外的抽象降低了性能。</li></ul><h3 id=解决方案>解决方案</h3><p><code>Docker</code>对于容器文件的持久化提供了两种方式：<code>volumes</code>、<code>bind mounts</code></p><p><img src=https://user-images.githubusercontent.com/5203608/166710239-5dbfaf24-67bc-4c76-b287-0c8c625141d0.png alt=image></p><p>tips:</p><ul><li><p><strong>Volumes</strong> are stored in a part of the host filesystem which is managed by Docker (<code>/var/lib/docker/volumes/</code> on Linux). Non-Docker processes should not modify this part of the filesystem. Volumes are the best way to persist data in Docker.</p></li><li><p><strong>Bind mounts</strong> may be stored anywhere on the host system. They may even be important system files or directories. Non-Docker processes on the Docker host or a Docker container can modify them at any time.</p></li><li><p><strong>tmpfs mounts</strong> are stored in the host system’s memory only, and are never written to the host system’s filesystem.</p></li></ul><h2 id=volumes>Volumes</h2><h3 id=介绍>介绍</h3><p>通过阅读docker的官方文档其实感觉到一直尽力地告诉你<code>volumes</code>是docker数据持久化的首选机制。</p><p>对于volume有两种使用方式， <code>named volumes</code>/ <code>anonymous volumes</code>. 匿名卷（<code>anonymous volumes</code>）在第一次挂载到容器中时没有明确的名称，所以Docker给它们一个随机的名称，保证在特定的Docker主机中是唯一的。 除了名字, 命名卷与匿名卷其他的表现均是一样的。</p><p><code>Volumes</code>另外还支持使用<code>Volume drivers</code>，允许你将数据存储在远程主机或云供应商，以及其他可能性。</p><h3 id=volumes-in-real-world>volumes in real world</h3><p>我们基于<code>mysql</code>的容器来做一个说明，我们创建一个 <code>data_volume</code>的volumes 用来存储mysql的数据， 如下图：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#888># create data_volume for mysql container</span>
docker volume create data_volume
docker run -v data_volume:/var/lib/mysql mysql

<span style=color:#888># 如果不提前创建 data_volume2, docker会自动创建这个volume</span>
docker run -v data_volume2:/var/lib/mysql mysql 
</code></pre></div><p><img src=https://user-images.githubusercontent.com/5203608/166905854-e0c845ad-407c-42bf-ac0a-d74e87abb35a.png alt=image></p><h2 id=bind-mounts>Bind mounts</h2><p>对于数据持久化<code>bind mounts</code>在<code>Docker</code>的早期就已经存在了，挂载的文件或目录不需要在Docker主机上已经存在。如果它还不存在就会按需创建。绑定挂载的性能非常好，但它们依赖于主机的文件系统有一个特定的目录结构。</p><p>但是如果你正在开发新的Docker应用程序，请考虑使用<code>named volumes</code>.</p><h3 id=bind-mounts-in-real-world>bind mounts in real world</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>docker run -v /data/mysql:/var/lib/mysql mysql
</code></pre></div><p><img src=https://user-images.githubusercontent.com/5203608/166928022-f67cb581-9142-4f9f-b30e-1c22dc5d6457.png alt=image></p><h3 id=tips>tips</h3><ul><li><strong>Bind mounts allow access to sensitive files</strong>
One side effect of using bind mounts, for better or for worse, is that you can change the host filesystem via processes running in a container, including creating, modifying, or deleting important system files or directories. This is a powerful ability which can have security implications, including impacting non-Docker processes on the host system.</li></ul><h2 id=关于挂载方式--v-or---mount>关于挂载方式 -v or &ndash;mount</h2><h3 id=概述>概述</h3><p><code>-v</code> 是旧的一种命令方式，建议使用<code>--mount</code>选项，因为它更详细，必须以key/value的格式来指定每个参数（其实这个你也可以理解为缺点，有些麻烦）。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#888># volumes</span>
docker run <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>--mount <span style=color:#963>type</span><span style=color:#333>=</span>volume, <span style=color:#963>source</span><span style=color:#333>=</span>data_volume, <span style=color:#963>target</span><span style=color:#333>=</span>/var/lib/mysql mysql
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#888># bind mounts</span>
docker run <span style=color:#666;background-color:#fff0f0;font-weight:700>\
</span><span style=color:#666;background-color:#fff0f0;font-weight:700></span>--mount <span style=color:#963>type</span><span style=color:#333>=</span>bind, <span style=color:#963>source</span><span style=color:#333>=</span>/data/mysql, <span style=color:#963>target</span><span style=color:#333>=</span>/var/lib/mysql mysql
</code></pre></div><h3 id=参数说明>参数说明</h3><ul><li><p>The <code>type</code> of the mount, which can be <code>bind</code>, <code>volume</code>, or <code>tmpfs</code>.</p></li><li><p>The <code>source</code> of the mount.</p><ul><li>For named volumes, this is the name of the volume.</li><li>For anonymous volumes, this field is omitted. May be specified as <code>source</code> or <code>src</code>.</li><li>For <code>bind mounts</code>, this is the path to the file or directory on the Docker daemon host. May be specified as source or src.</li></ul></li><li><p>The <code>destination</code> takes as its value the path where the file or directory is mounted in the container. May be specified as <code>destination</code>, <code>dst</code>, or <code>target</code>.</p></li><li><p>The <code>readonly</code> option, if present, causes the bind mount to be <a href=%5Bmounted%5D(https://docs.docker.com/storage/volumes/#use-a-read-only-volume)>mounted into the container as read-only</a>. May be specified as <code>readonly</code> or <code>ro</code>.</p></li><li><p>volumes options (work with volumes)</p><ul><li>The <code>volume-opt</code> option, which can be specified more than once, takes a key-value pair consisting of the option name and its value.</li></ul></li><li><p>bind mounts options (work with bind mounts)</p><ul><li>The <code>bind-propagation</code> option, if present, changes the bind propagation. May be one of <code>rprivate</code>, <code>private</code>, <code>rshared</code>, <code>shared</code>, <code>rslave</code>, <code>slave</code></li></ul></li></ul><h2 id=good-use-cases-for-volumesbind-mounts>Good use cases for volumes/bind mounts</h2><h3 id=for-volumes>For volumes</h3><ul><li>Sharing data among multiple running containers.</li><li>When you want to store your container’s data on a remote host or a cloud provider, rather than locally.（volume driver）</li><li>When you need to back up, restore, or migrate data from one Docker host to another, volumes are a better choice.</li><li>When your application requires <strong>high-performance I/O</strong> on Docker Desktop. Volumes are stored in the Linux VM rather than the host, which means that the reads and writes have much lower latency and higher throughput.</li><li>使用 <code>volume</code>可以屏蔽掉多os系统文件系统的差异，统一有<code>docker volume</code>来管理</li></ul><h3 id=for-bind-mounts>for bind mounts</h3><ul><li>Sharing configuration files from the host machine to containers. 比如解决时区、dns问题等</li><li>When the file or directory structure of the Docker host is guaranteed to be consistent with the bind mounts the containers require.</li></ul><h2 id=结论>结论</h2><p>对于<code>volume</code>与<code>bind mounts</code>通过上文的讨论，你应该知道如何选择，确实<code>volume</code>看起来是一个更完整的设计，也推荐你使用；你可以在<code>docker run</code>或是<code>docker-compose</code>中好好享受<code>volume</code>，但是在<code>dockerfile</code>不建议使用<code>volume</code>来声明volume, 更多地可以看<a href=https://github.com/warm-native/docs/blob/master/docker/dockerfile-guide.md#volume>这里的说明</a></p><h2 id=reference-to>Reference to</h2><ul><li><a href=https://docs.docker.com/storage/>docker storage</a></li><li><a href=https://github.com/warm-native/docs/blob/master/docker/dockerfile-guide.md>dockerfile guide</a></li></ul><p><img src=https://user-images.githubusercontent.com/5203608/166955094-df7958d2-4327-4c57-b2fd-ed4f2c25d4e1.png alt=云原生运维实践-mp></p></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Colynn.Liu</span></p><p class=copyright-item><span>Link:</span>
<a href=https://colynn.github.io/2022-05-02-docker-volume/>https://colynn.github.io/2022-05-02-docker-volume/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://colynn.github.io/tags/docker/>#docker</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://colynn.github.io/>home</a></span></section></div><div class=post-nav><a href=https://colynn.github.io/2021-08-12-k8s-operator/ class=prev rel=prev title="Kubernetes Operator"><i class="iconfont icon-left"></i>&nbsp;Kubernetes Operator</a></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script>const gitalk=new Gitalk({clientID:'7196948b9a586a342072',clientSecret:"1acf6a13bc1ce7b8d8e3554789781ba2aaa4575c",repo:"blog-comments",owner:"colynn",admin:"colynn",id:"/2022-05-02-docker-volume/",distractionFreeMode:false,perPage:100});gitalk.render('gitalk-container')</script></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2018 - 2022</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://colynn.github.io/>Colynn.Liu</a> |</span>
<span><a href=https://colynn.github.io/friends>友情链接</a></span></div></footer><link href=//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css rel=stylesheet><script src=/js/vendor_gallery.min.js async></script></div></body></html>