<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Colynn.Liu"><meta name=description content="Full-Stack DevOps, Be focused and Practical"><link rel=prev href=https://colynn.github.io/2020-05-25-jwt-auth/><link rel=next href=https://colynn.github.io/2020-06-11-unicode-utf8/><link rel=canonical href=https://colynn.github.io/2020-06-01-vue-in-using-summaring/><link rel=apple-touch-icon sizes=180x180 href=/img/home-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>vue 使用中的汇总 | Colynn.Liu</title><meta name=title content="vue 使用中的汇总 | Colynn.Liu"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/colynn.github.io\/"},"articleSection":"posts","name":"vue 使用中的汇总","headline":"vue 使用中的汇总","description":"Vue 生命周期 Vue 路由 1. Vue 路由跳转方式 1. router-link 1.不带参数 \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;home\u0026#39;}\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;{path:\u0026#39;\/home\u0026#39;}\u0026#34;\u0026gt; \/\/name,path都行, 建议用name \/\/ 注意：router-link中链接如果是","inLanguage":"zh-CN","author":"Colynn.Liu","creator":"Colynn.Liu","publisher":"Colynn.Liu","accountablePerson":"Colynn.Liu","copyrightHolder":"Colynn.Liu","copyrightYear":"2020","datePublished":"2020-06-01 00:00:00 \u002b0000 UTC","dateModified":"2020-06-01 00:00:00 \u002b0000 UTC","url":"https:\/\/colynn.github.io\/2020-06-01-vue-in-using-summaring\/","wordCount":"2713","keywords":["vue","js","Colynn.Liu"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/readings/>书单</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/readings/>书单</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">vue 使用中的汇总</h1><div class=post-meta>Written by <a itemprop=name href=https://colynn.github.io/ rel=author>Colynn.Liu</a> with ♥
<span class=post-time>on <time datetime=2020-06-01 itemprop=datePublished>June 1, 2020</time></span>
<span class=post-time>- last modified on <time datetime=2020-06-01 itemprop=datePublished>January 25, 2021</time></span></div><div class=post-tags><section><span class=tag><a href=https://colynn.github.io/tags/vue/><i class="iconfont icon-tag"></i>vue</a></span>
<span class=tag><a href=https://colynn.github.io/tags/js/><i class="iconfont icon-tag"></i>js</a></span></section><section><i class="iconfont icon-folder"></i><span class=post-category><a href=https://colynn.github.io/categories/%E6%95%99%E7%A8%8B/>教程</a></span></section></div></header><div class=post-content><h1 id=vue-生命周期>Vue 生命周期</h1><p><img src=https://user-images.githubusercontent.com/5203608/89412164-2e798b00-d759-11ea-82b8-324f3d18e5e4.png alt=image></p><h1 id=vue-路由>Vue 路由</h1><h2 id=1-vue-路由跳转方式>1. Vue 路由跳转方式</h2><h3 id=1-router-link>1. router-link</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#60e;font-weight:700>1.</span>不带参数

<span style=color:#333>&lt;</span>router<span style=color:#333>-</span>link <span style=color:#333>:</span>to<span style=color:#333>=</span><span style=background-color:#fff0f0>&#34;{name:&#39;home&#39;}&#34;</span><span style=color:#333>&gt;</span> 
<span style=color:#333>&lt;</span>router<span style=color:#333>-</span>link <span style=color:#333>:</span>to<span style=color:#333>=</span><span style=background-color:#fff0f0>&#34;{path:&#39;/home&#39;}&#34;</span><span style=color:#333>&gt;</span> <span style=color:#888>//name,path都行, 建议用name  
</span><span style=color:#888>// 注意：router-link中链接如果是&#39;/&#39;开始就是从根路由开始，如果开始不带&#39;/&#39;，则从当前路由开始。
</span><span style=color:#888></span> 
<span style=color:#60e;font-weight:700>2.</span>带参数
 
<span style=color:#333>&lt;</span>router<span style=color:#333>-</span>link <span style=color:#333>:</span>to<span style=color:#333>=</span><span style=background-color:#fff0f0>&#34;{name:&#39;home&#39;, params: {id:1}}&#34;</span><span style=color:#333>&gt;</span>  
 
<span style=color:#888>// params传参数 (类似post)
</span><span style=color:#888>// 路由配置 path: &#34;/home/:id&#34; 或者 path: &#34;/home:id&#34; 
</span><span style=color:#888>// 不配置path ,第一次可请求,刷新页面id会消失
</span><span style=color:#888>// 配置path,刷新页面id会保留
</span><span style=color:#888></span> 
<span style=color:#888>// html 取参  $route.params.id
</span><span style=color:#888>// script 取参  this.$route.params.id
</span><span style=color:#888></span> 
 
<span style=color:#333>&lt;</span>router<span style=color:#333>-</span>link <span style=color:#333>:</span>to<span style=color:#333>=</span><span style=background-color:#fff0f0>&#34;{name:&#39;home&#39;, query: {id:1}}&#34;</span><span style=color:#333>&gt;</span> 
 
<span style=color:#888>// query传参数 (类似get,url后面会显示参数)
</span><span style=color:#888>// 路由可不配置
</span><span style=color:#888></span> 
<span style=color:#888>// html 取参  $route.query.id
</span><span style=color:#888>// script 取参  this.$route.query.id
</span><span style=color:#888></span>
</code></pre></div><h3 id=2-thisrouterpush-函数里面调用>2. this.$router.push() (函数里面调用)</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#60e;font-weight:700>1.</span>不带参数
 
<span style=color:#080;font-weight:700>this</span>.$router.push(<span style=background-color:#fff0f0>&#39;/home&#39;</span>)
<span style=color:#080;font-weight:700>this</span>.$router.push({name<span style=color:#333>:</span><span style=background-color:#fff0f0>&#39;home&#39;</span>})
<span style=color:#080;font-weight:700>this</span>.$router.push({path<span style=color:#333>:</span><span style=background-color:#fff0f0>&#39;/home&#39;</span>})
 

<span style=color:#60e;font-weight:700>2.</span> query传参 
 
<span style=color:#080;font-weight:700>this</span>.$router.push({name<span style=color:#333>:</span><span style=background-color:#fff0f0>&#39;home&#39;</span>,query<span style=color:#333>:</span> {id<span style=color:#333>:</span><span style=background-color:#fff0f0>&#39;1&#39;</span>}})
<span style=color:#080;font-weight:700>this</span>.$router.push({path<span style=color:#333>:</span><span style=background-color:#fff0f0>&#39;/home&#39;</span>,query<span style=color:#333>:</span> {id<span style=color:#333>:</span><span style=background-color:#fff0f0>&#39;1&#39;</span>}})
 
<span style=color:#888>// html 取参  $route.query.id
</span><span style=color:#888>// script 取参  this.$route.query.id
</span><span style=color:#888></span><span style=color:#60e;font-weight:700>3.</span> params传参
 
<span style=color:#080;font-weight:700>this</span>.$router.push({name<span style=color:#333>:</span><span style=background-color:#fff0f0>&#39;home&#39;</span>,params<span style=color:#333>:</span> {id<span style=color:#333>:</span><span style=background-color:#fff0f0>&#39;1&#39;</span>}})  <span style=color:#888>// 只能用 name
</span><span style=color:#888></span> 
<span style=color:#888>// 路由配置 path: &#34;/home/:id&#34; 或者 path: &#34;/home:id&#34; ,
</span><span style=color:#888>// 不配置path ,第一次可请求,刷新页面id会消失
</span><span style=color:#888>// 配置path,刷新页面id会保留
</span><span style=color:#888></span> 
<span style=color:#888>// html 取参  $route.params.id
</span><span style=color:#888>// script 取参  this.$route.params.id
</span><span style=color:#888></span>
 
<span style=color:#60e;font-weight:700>4.</span> query和params区别
query类似 get, 跳转之后页面 url后面会拼接参数,类似<span style=color:#333>?</span>id<span style=color:#333>=</span><span style=color:#00d;font-weight:700>1</span>, 非重要性的可以这样传, 密码之类还是用params刷新页面id还在
 
params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失

</code></pre></div><h3 id=3--thisrouterreplace-用法同上push>3. this.$router.replace() (用法同上,push)</h3><h3 id=4--thisroutergon>4. this.$router.go(n)</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#080;font-weight:700>this</span>.$router.go(n)
向前或者向后跳转n个页面<span style=color:red;background-color:#faa>，</span>n可为正整数或负整数
</code></pre></div><ul><li><p><code>this.$router.push</code> 跳转到指定url路径，并想history栈中添加一个记录，点击后退会返回到上一个页面</p></li><li><p><code>this.$router.replace</code>
跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面)</p></li><li><p><code>this.$router.go(n)</code>
向前或者向后跳转n个页面，n可为正整数或负整数</p></li></ul><h2 id=2-动态路由的思考>2. 动态路由的思考</h2><h3 id=前言>前言</h3><p>先说下为什么需要动态路由？比如我们想让不同的角色看到不同的菜单及页面，你均通过 <code>v-show</code>或是<code>if</code>语句，你觉得还够用吗？这个时候动态路由就显得特别重要。</p><h3 id=如何解决>如何解决</h3><p>实现用户角色菜单及页面的控制，需要解决两个问题：
问题1. 根据用户拥有的权限id的集合决定用户能访问哪些前端路由；
问题2. 根据用户拥有的权限id的集合决定用户能看到哪些按钮或者模块。</p><p>对于问题1，我们在用户登录后首先获取相应的路由信息，然后通过<code>vue-router</code>的<code>addRouters</code> 添加至前端路由中即可，但是有个问题，由于用户的信息是存放在 vuex 中，刷新页面时就会导致404。
* 当然你可以把权限存放至浏览器的 <code>sessionStorage</code> 中，每次刷新并不会清空用户权限，但是这样做的话，用户手动改一下 <code>sessionStorage</code>就能看到其他页面，不是很完美的方案，而且需要二次存储（vuex/ sessionStorage）;
* vue 提供了一个<code>Navigation Guards</code>的功能，这样页面加载时我们可以先初始化一个空路由（或是默认均开放给用户的路由），紧接校验用户信息，没有的话就再次请求权限，然后通过<code>addRouters</code> 添加路由， 目前来看应该是相对完美的方案。</p><p>对于问题2，可以添加<a href=https://vuejs.org/v2/guide/custom-directive.html>自定义的vue命令来控制</a></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#888>// custom-directive
</span><span style=color:#888></span>Vue.directive(<span style=background-color:#fff0f0>&#39;permissionaction&#39;</span>, {
  inserted<span style=color:#333>:</span> <span style=color:#080;font-weight:700>function</span>(el, binding) {
      <span style=color:#080;font-weight:700>const</span> { value } <span style=color:#333>=</span> binding
      <span style=color:#080;font-weight:700>const</span> all_permission <span style=color:#333>=</span> <span style=background-color:#fff0f0>&#39;*:*:*&#39;</span>
      <span style=color:#080;font-weight:700>const</span> permissions <span style=color:#333>=</span> store.getters <span style=color:#333>&amp;&amp;</span> store.getters.permisaction

      <span style=color:#080;font-weight:700>if</span> (value <span style=color:#333>&amp;&amp;</span> value <span style=color:#080;font-weight:700>instanceof</span> <span style=color:#007020>Array</span> <span style=color:#333>&amp;&amp;</span> value.length <span style=color:#333>&gt;</span> <span style=color:#00d;font-weight:700>0</span>) {
          <span style=color:#080;font-weight:700>const</span> permissionFlag <span style=color:#333>=</span> value

          <span style=color:#080;font-weight:700>const</span> hasPermissions <span style=color:#333>=</span> permissions.some(permission =&gt; {
              <span style=color:#080;font-weight:700>return</span> all_permission <span style=color:#333>===</span> permission <span style=color:#333>||</span> permissionFlag.includes(permission)
          })

          <span style=color:#080;font-weight:700>if</span> (<span style=color:#333>!</span>hasPermissions) {
              el.parentNode <span style=color:#333>&amp;&amp;</span> el.parentNode.removeChild(el)
          } <span style=color:#080;font-weight:700>else</span> {
            <span style=color:#080;font-weight:700>throw</span> <span style=color:#080;font-weight:700>new</span> <span style=color:#007020>Error</span>(<span style=background-color:#fff0f0>`请设置操作权限标签值`</span>)
          }
      }
    }
  }
)

</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#888>// component use
</span><span style=color:#888></span><span style=color:#333>&lt;</span>button v<span style=color:#333>-</span>permissionaction<span style=color:#333>=</span>[<span style=background-color:#fff0f0>&#34;permission_id&#34;</span>]<span style=color:#333>&gt;</span>删除<span style=color:#333>&lt;</span><span style=color:red;background-color:#faa>/button&gt;</span>
</code></pre></div><h3 id=注意点>注意点</h3><ol><li><p><code>vue-router</code> 提供了<code>addRouters</code>来进行添加路由，但是却没有移除路由的相关选项，当切换用户或是变更角色时，可以另外创建一个 router实例来替换之前的实例。 <a href=https://github.com/vuejs/vue-router/issues/1234#issuecomment-357941465>详见这里-Feature request: replace routes dynamically</a></p></li><li><p>Vue mathcing priority: the earlier a route is defined, the higher priority it gets, 所以如果你想匹配其他的页面至 /404, 请你一定将 <code>{ path: '*', redirect: '/404', hidden: true }</code> 定义至路由的 <strong>最后</strong>。</p></li></ol><h1 id=vue-state-management>Vue State Management</h1><h2 id=核心-concepts>核心 Concepts</h2><h3 id=state>State</h3><p>Vuex uses a <code>single state tree</code> - that is, this single object contains all your application level state and serves as the &ldquo;single source of truth&rdquo;.</p><p><em>注</em>: the <code>mapState</code> helper. When a component needs to make use of multiple store state properties or getters, declaring all these computed properties can get repetitive and verbose. To deal with this we can make use of the <code>mapState</code> helper which generates computed getter functions for us, saving us some keystrokes（简化我们的输入）.</p><h3 id=getters>Getters</h3><p>Sometimes we may need to compute derived state based on store state, Vuex allows us to define <code>getters</code> in the store. You can think of them as computed properties for stores.</p><p>Getters will receive the <code>state</code> as their 1st argument:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#080;font-weight:700>const</span> store <span style=color:#333>=</span> <span style=color:#080;font-weight:700>new</span> Vuex.Store({
  state<span style=color:#333>:</span> {
    todos<span style=color:#333>:</span> [
      { id<span style=color:#333>:</span> <span style=color:#00d;font-weight:700>1</span>, text<span style=color:#333>:</span> <span style=background-color:#fff0f0>&#39;...&#39;</span>, done<span style=color:#333>:</span> <span style=color:#080;font-weight:700>true</span> },
      { id<span style=color:#333>:</span> <span style=color:#00d;font-weight:700>2</span>, text<span style=color:#333>:</span> <span style=background-color:#fff0f0>&#39;...&#39;</span>, done<span style=color:#333>:</span> <span style=color:#080;font-weight:700>false</span> }
    ]
  },
  getters<span style=color:#333>:</span> {
    doneTodos<span style=color:#333>:</span> state =&gt; {
      <span style=color:#080;font-weight:700>return</span> state.todos.filter(todo =&gt; todo.done)
    }
  }
})

</code></pre></div><p><strong>注</strong>: the <code>mapGetters</code> helper simply maps store getters to local computed properties.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#080;font-weight:700>import</span> { mapGetters } from <span style=background-color:#fff0f0>&#39;vuex&#39;</span>

<span style=color:#080;font-weight:700>export</span> <span style=color:#080;font-weight:700>default</span> {
  <span style=color:#888>// ...
</span><span style=color:#888></span>  computed<span style=color:#333>:</span> {
    <span style=color:#888>// mix the getters into computed with object spread operator
</span><span style=color:#888></span>    ...mapGetters([
      <span style=background-color:#fff0f0>&#39;doneTodosCount&#39;</span>,
      <span style=background-color:#fff0f0>&#39;anotherGetter&#39;</span>,
      <span style=color:#888>// ...
</span><span style=color:#888></span>    ])
  }
}
</code></pre></div><p>If you want to map a getter to a different name, use an object:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>...mapGetters({
  <span style=color:#888>// map `this.doneCount` to `this.$store.getters.doneTodosCount`
</span><span style=color:#888></span>  doneCount<span style=color:#333>:</span> <span style=background-color:#fff0f0>&#39;doneTodosCount&#39;</span>
})
</code></pre></div><h3 id=mutations>Mutations</h3><p>The only way to actually change state in a Vuex store is by committing a mutation. Vuex mutations are very similar to events: each mutation has a string <code>type</code> and a <code>handler</code>.</p><p><strong>注</strong>： Mutations Must Be Synchronous</p><h3 id=actions>Actions</h3><p>Actions are similar to mutations, the differences being that:</p><ul><li>Instead of mutating the state, actions commit mutations.</li><li>Actions can contain arbitrary asynchronous operations.</li></ul><h3 id=modules>Modules</h3><p>Due to using a single state tree, all state of our application is contained inside one big object. However, as our application grows in scale, the store can get really bloated.</p><p>To help with that, Vuex allows us to divide our store into <code>modules</code>. Each module can contain its own state, mutations, actions, getters, and even nested modules</p><ul><li><p>By default, actions, mutations and getters inside modules are still registered under the <code>global namespace</code> - this allows multiple modules to react to the same mutation/action type.</p></li><li><p>If you want your modules to be more self-contained or reusable, you can mark it as namespaced with <code>namespaced: true</code>. When the module is registered, all of its getters, actions and mutations will be automatically namespaced based on the path the module is registered at.</p></li></ul><h3 id=参考>参考</h3><ol><li><a href=https://vuex.vuejs.org/guide/modules.html>https://vuex.vuejs.org/guide/modules.html</a></li></ol><h1 id=附录>附录</h1><h2 id=1scoped-css>1.Scoped CSS</h2><ol><li>含义</li></ol><p>当 <code>&lt;style></code>标签有 <code>scoped</code>属性时，css 样式仅会应用在当前组件内。 父组件的样式不会影响子组件，然而子组件的根节点均会被父节点及子节点的<code>scoped</code>样式影响。这样是为了统一布局，父组件可以定义子组件的根元素。</p><ol start=2><li>如何使用</li></ol><p>你可以在一个组件内使用<code>scoped</code>和<code>non-scoped</code>样式：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#333>&lt;</span>style<span style=color:#333>&gt;</span>
<span style=color:#888>/* global styles */</span>
<span style=color:#333>&lt;</span><span style=color:red;background-color:#faa>/style&gt;</span>

<span style=color:#333>&lt;</span>style scoped<span style=color:#333>&gt;</span>
<span style=color:#888>/* local styles */</span>
<span style=color:#333>&lt;</span><span style=color:red;background-color:#faa>/style&gt;</span>

</code></pre></div><ol start=3><li>Deep Selectors</li></ol><p>如果你想在一个包含<code>scoped</code>样式的selector 可以深度选择， 比如，影响子组件，你可以使用<code>>>></code>选择符：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#333>&lt;</span>style scoped<span style=color:#333>&gt;</span>
.a <span style=color:#333>&gt;&gt;&gt;</span> .b { <span style=color:#888>/* ... */</span> }
<span style=color:#333>&lt;</span><span style=color:red;background-color:#faa>/style&gt;</span>
</code></pre></div><p>The above will be compiled into:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>.a[data<span style=color:#333>-</span>v<span style=color:#333>-</span>f3f3eg9] .b { <span style=color:#888>/* ... */</span> }
</code></pre></div><p>一些预解释器（像 Sass）, 也许不能正确地解析 <code>>>></code>.在这种情况下，你可以使用 <code>/deep/</code> 或是<code>::v-deep</code> 选择符来替代。</p><ol start=4><li>Dynamically Generated Content</li></ol><p>DOM content created with v-html are not affected by scoped styles, but you can still style them using deep selectors.
通过<code>v-html</code>创建的 DOM内容，不被<code>scoped</code>样式影响， 但是你可以使用<code>deep selector</code>改变样式。</p><h2 id=2-import-syntax>2. import syntax</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#080;font-weight:700>import</span> defaultExport from <span style=background-color:#fff0f0>&#34;module-name&#34;</span>;
<span style=color:#080;font-weight:700>import</span> <span style=color:#333>*</span> as name from <span style=background-color:#fff0f0>&#34;module-name&#34;</span>;
<span style=color:#080;font-weight:700>import</span> { export1 } from <span style=background-color:#fff0f0>&#34;module-name&#34;</span>;
<span style=color:#080;font-weight:700>import</span> { export1 as alias1 } from <span style=background-color:#fff0f0>&#34;module-name&#34;</span>;
<span style=color:#080;font-weight:700>import</span> { export1 , export2 } from <span style=background-color:#fff0f0>&#34;module-name&#34;</span>;
<span style=color:#080;font-weight:700>import</span> { foo , bar } from <span style=background-color:#fff0f0>&#34;module-name/path/to/specific/un-exported/file&#34;</span>;
<span style=color:#080;font-weight:700>import</span> { export1 , export2 as alias2 , [...] } from <span style=background-color:#fff0f0>&#34;module-name&#34;</span>;
<span style=color:#080;font-weight:700>import</span> defaultExport, { export1 [ , [...] ] } from <span style=background-color:#fff0f0>&#34;module-name&#34;</span>;
<span style=color:#080;font-weight:700>import</span> defaultExport, <span style=color:#333>*</span> as name from <span style=background-color:#fff0f0>&#34;module-name&#34;</span>;
<span style=color:#080;font-weight:700>import</span> <span style=background-color:#fff0f0>&#34;module-name&#34;</span>;
<span style=color:#080;font-weight:700>var</span> promise <span style=color:#333>=</span> <span style=color:#080;font-weight:700>import</span>(<span style=background-color:#fff0f0>&#34;module-name&#34;</span>);
</code></pre></div><ul><li><p><strong>defaultExport</strong>
Name that will refer to the default export from the module.</p></li><li><p><strong>module-name</strong>
The module to import from. This is often a relative or absolute path name to the .js file containing the module. Certain bundlers may permit or require the use of the extension; check your environment. Only single quoted and double quoted Strings are allowed.</p></li><li><p><strong>name</strong>
Name of the module object that will be used as a kind of namespace when referring to the imports.</p></li><li><p><strong>exportN</strong>
Name of the exports to be imported.</p></li><li><p><strong>aliasN</strong>
Names that will refer to the named imports.</p></li></ul><h2 id=3-vue-warn-avoid-using-non-primitive-value-as-key-use-stringnumber-value-instead>3. [Vue warn]: Avoid using non-primitive value as key, use string/number value instead</h2><p><strong>注</strong>: Don’t use non-primitive values like objects and arrays as <code>v-for</code> keys. Use string or numeric values instead.</p><p>To give Vue a hint so that it can track each node’s identity, and thus reuse and reorder existing elements, you need to provide a unique <code>key</code> attribute for each item:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#070>div</span> <span style=color:#00c>v-for</span><span style=color:#333>=</span><span style=background-color:#fff0f0>&#34;item in items&#34;</span> <span style=color:#00c>v-bind:key</span><span style=color:#333>=</span><span style=background-color:#fff0f0>&#34;item.id&#34;</span>&gt;
  <span style=color:#888>&lt;!-- content --&gt;</span>
&lt;/<span style=color:#070>div</span>&gt;
</code></pre></div><p>It is recommended to provide a <code>key</code> attribute with <code>v-for</code> whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</p><p>Since it’s a generic mechanism for Vue to identify nodes, the <code>key</code> also has other uses that are not specifically tied to <code>v-for</code>, as we will see later in the guide.</p><h2 id=3-vue-editor>3. Vue editor</h2><p><a href=https://github.com/colynn-demo/vuehello/tree/master/src/components/Editor>vue oneline editor 组件</a></p><h2 id=4-常见问题>4. 常见问题</h2><ol><li><code>vue.runtime.min.js:6 TypeError: Cannot read property '_withTask' of undefined</code></li></ol><p><strong>问题及解决方案</strong>: 因为使用了未定义的方法， 请确认将使用的方法添加至 <code>methods {}</code>内.</p><h2 id=参考-1>参考</h2><ol><li><a href=https://vue-loader.vuejs.org/guide/scoped-css.html#deep-selectors>Scoped CSS</a></li></ol></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Colynn.Liu</span></p><p class=copyright-item><span>Link:</span>
<a href=https://colynn.github.io/2020-06-01-vue-in-using-summaring/>https://colynn.github.io/2020-06-01-vue-in-using-summaring/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://colynn.github.io/tags/vue/>#vue</a></span>
<span class=tag><a href=https://colynn.github.io/tags/js/>#js</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://colynn.github.io/>home</a></span></section></div><div class=post-nav><a href=https://colynn.github.io/2020-05-25-jwt-auth/ class=prev rel=prev title="Jwt web token - What & How & FAQ"><i class="iconfont icon-left"></i>&nbsp;Jwt web token - What & How & FAQ</a>
<a href=https://colynn.github.io/2020-06-11-unicode-utf8/ class=next rel=next title="ASCII, Unicode, UTF-8 字符编码">ASCII, Unicode, UTF-8 字符编码&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script>const gitalk=new Gitalk({clientID:'7196948b9a586a342072',clientSecret:"1acf6a13bc1ce7b8d8e3554789781ba2aaa4575c",repo:"blog-comments",owner:"colynn",admin:"colynn",id:"/2020-06-01-vue-in-using-summaring/",distractionFreeMode:false,perPage:100});gitalk.render('gitalk-container')</script></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2018 - 2023</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://colynn.github.io/>Colynn.Liu</a> |</span>
<span><a href=https://colynn.github.io/friends>友情链接</a></span></div></footer><link href=//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css rel=stylesheet><script src=/js/vendor_gallery.min.js async></script></div></body></html>