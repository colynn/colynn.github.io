<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Colynn.Liu"><link rel=prev href=https://colynn.github.io/2019-12-31-go_basic_knowledge_summarizing/><link rel=next href=https://colynn.github.io/2019-08-15-introducing_go_mod/><link rel=canonical href=https://colynn.github.io/2019-07-26-basic_knowledge_summarizing/><link rel=apple-touch-icon sizes=180x180 href=/img/home-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>python 语法汇总 | Colynn.Liu</title><meta name=title content="python 语法汇总 | Colynn.Liu"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/colynn.github.io\/"},"articleSection":"posts","name":"python 语法汇总","headline":"python 语法汇总","description":"列表与元组的区别； 语法差异：声名方式不同 第一个不同点是元组的声明使用小括号，而列表使用方括号，当声明只有一个元素的元组时，需要在这个元素的后","inLanguage":"zh-CN","author":"Colynn.Liu","creator":"Colynn.Liu","publisher":"Colynn.Liu","accountablePerson":"Colynn.Liu","copyrightHolder":"Colynn.Liu","copyrightYear":"2019","datePublished":"2019-07-26 00:00:00 \u002b0000 UTC","dateModified":"2019-07-26 00:00:00 \u002b0000 UTC","url":"https:\/\/colynn.github.io\/2019-07-26-basic_knowledge_summarizing\/","wordCount":"963","keywords":["python","Colynn.Liu"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">python 语法汇总</h1><div class=post-meta>Written by <a itemprop=name href=https://colynn.github.io/ rel=author>Colynn.Liu</a> with ♥
<span class=post-time>on <time datetime=2019-07-26 itemprop=datePublished>July 26, 2019</time></span>
<span class=post-time>- last modified <time datetime=2019-07-26 itemprop=datePublished>July 26, 2019</time></span></div><div class=post-tags><section><span class=tag><a href=https://colynn.github.io/tags/python/><i class="iconfont icon-tag"></i>python</a></span></section><section><i class="iconfont icon-folder"></i><span class=post-category><a href=https://colynn.github.io/categories/%E5%9F%BA%E7%A1%80%E6%89%8B%E5%86%8C/>基础手册</a></span></section></div></header><div class=post-content><h3 id=列表与元组的区别>列表与元组的区别；</h3><ol><li><p><strong>语法差异：声名方式不同</strong> 第一个不同点是元组的声明使用小括号，而列表使用方括号，当声明只有一个元素的元组时，需要在这个元素的后面添加英文逗号；</p></li><li><p><strong>不可修改类型</strong> 第二个不同点是元组声明和赋值后，不能像列表一样添加、删除和修改元素，也就是说元组在程序运行过程中不能被修改,无法复制。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#333>&gt;&gt;&gt;</span> copy_t <span style=color:#333>=</span> <span style=color:#007020>tuple</span>(t)
<span style=color:#333>&gt;&gt;&gt;</span> <span style=color:#080;font-weight:700>print</span>(t <span style=color:#000;font-weight:700>is</span> copy_t)
True
<span style=color:#333>&gt;&gt;&gt;</span> copy_l <span style=color:#333>=</span> <span style=color:#007020>list</span>(l)
<span style=color:#333>&gt;&gt;&gt;</span> <span style=color:#080;font-weight:700>print</span>(l <span style=color:#000;font-weight:700>is</span> copy_l)
False
</code></pre></div></li><li><p><strong>内存大小差异</strong> Python将低开销的较大的块分配给元组，因为它们是不可变的。 对于列表则分配小内存块。 与列表相比，元组的内存更小。 当你拥有大量元素时，元组比列表快。列表的长度是可变的。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#333>&gt;&gt;&gt;</span> l <span style=color:#333>=</span> [<span style=background-color:#fff0f0>&#39;https://china-testing.github.io/&#39;</span>, <span style=background-color:#fff0f0>&#39;https://www.soco.com&#39;</span>]
<span style=color:#333>&gt;&gt;&gt;</span> t <span style=color:#333>=</span> (<span style=background-color:#fff0f0>&#39;https://china-testing.github.io/&#39;</span>, <span style=background-color:#fff0f0>&#39;https://www.soco.com&#39;</span>)
<span style=color:#333>&gt;&gt;&gt;</span> <span style=color:#080;font-weight:700>print</span>(l<span style=color:#333>.</span>__sizeof__())
<span style=color:#00d;font-weight:700>56</span>
<span style=color:#333>&gt;&gt;&gt;</span> <span style=color:#080;font-weight:700>print</span>(t<span style=color:#333>.</span>_sizeof__())
<span style=color:#00d;font-weight:700>40</span>
</code></pre></div></li></ol><p><em>注</em>: 用于列表的排序、替换、添加等方法也不适用于元组，适用于元组的主要运算有元组的合并、遍历、长度、求元组的最大值和最小值等操作方法。</p><p>元组的不可修改特性可能会让元组变得非常不灵活，因为元组作为容器对象，很多时候需要对容器的元素进行修改，这在元组中是不允许的。元组可以说是列表数据的一种补充，数据的不可修改性在程序设计中也是非常重要的。</p><p><strong>例如</strong>，当需要将数据作为参数传递给API，但不希望API修改参数时，就可以传递一个元组类型；再如，当需要定义一组Key时，也可以采用元组类型。因此可以说元组和列表是互为补充的数据类型。</p><h3 id=元组是否可以作为字典的key-分场景>元组是否可以作为字典的key， 分场景；</h3><p>首先一个对象能不能作为字典的key, 就取决于其有没有__hash__方法。 所以除了容器对象（list/dist/set）和内部包含容器对象的tuple 是不可作为字典的key, 其他的对象都可以。</p><h3 id=容器类型的对象如字典的内存结构>容器类型的对象，如字典的内存结构</h3><p>字典的keys() 方法会在遍历前生成一个临时的列表，导致上面的代码消耗大量内存并且运行缓慢。正确的方式，是使用默认的 iterator。默认的 iterator 不会分配新内存，也就不会造成上面的性能问题</p><h3 id=迭代器生成器可迭代对象>迭代器、生成器、可迭代对象</h3><ol><li>基于一个可迭代对象（即容器对象 list/tuple/生成器/迭代器）可以产生的 生成器或迭代器；</li><li>迭代器、生成器 均有next()方法；</li><li>迭代器是一次性载入内存; 生成器使用了『惰性计算』/『延迟求值』的机制，在每次计算出一个条目后，把这个条目“产生”(yield)出来.</li></ol><h3 id=进程线程协程-应用场景>进程、线程、协程 应用场景</h3><h3 id=garbage-collectionscyclical-references>Garbage Collections/cyclical references</h3><p>Generational is a type of tracing grabage collection.</p><p>Generational Garbage Collection is based on the gheory that <strong>most objects die young</strong>.</p><h3 id=数据库索引>数据库索引</h3><h3 id=tcp-三次握手四次挥手>tcp 三次握手、四次挥手</h3><h3 id=赋值深拷贝浅拷贝>赋值，深拷贝，浅拷贝</h3><h3 id=with>with</h3><h3 id=闭包>闭包</h3><h3 id=排序算法及复杂度>排序算法及复杂度</h3></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Colynn.Liu</span></p><p class=copyright-item><span>Link:</span>
<a href=https://colynn.github.io/2019-07-26-basic_knowledge_summarizing/>https://colynn.github.io/2019-07-26-basic_knowledge_summarizing/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://colynn.github.io/tags/python/>#python</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://colynn.github.io/>home</a></span></section></div><div class=post-nav><a href=https://colynn.github.io/2019-12-31-go_basic_knowledge_summarizing/ class=prev rel=prev title=Go语法汇总><i class="iconfont icon-left"></i>&nbsp;Go语法汇总</a>
<a href=https://colynn.github.io/2019-08-15-introducing_go_mod/ class=next rel=next title="Go Mod 包管理">Go Mod 包管理&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><script src=https://utteranc.es/client.js repo=colynn/blog-comments issue-term=pathname label=utterances theme=github-light crossorigin=anonymous async></script></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2018 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://colynn.github.io/>Colynn.Liu</a> |</span>
<span><a href=https://colynn.github.io/friends>友情链接</a></span></div></footer><script src=/js/vendor_no_gallery.min.js async></script></div></body></html>