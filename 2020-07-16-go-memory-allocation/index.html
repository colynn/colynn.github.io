<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Colynn.Liu"><meta name=description content="Full-Stack DevOps, Be focused and Practical"><link rel=prev href=https://colynn.github.io/2020-04-10-kubernetes-networking-flannel-calico/><link rel=next href=https://colynn.github.io/2020-05-06-slice-internal/><link rel=canonical href=https://colynn.github.io/2020-07-16-go-memory-allocation/><link rel=apple-touch-icon sizes=180x180 href=/img/home-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Golang 内存分配 - stack and heap | Colynn.Liu</title><meta name=title content="Golang 内存分配 - stack and heap | Colynn.Liu"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/colynn.github.io\/"},"articleSection":"posts","name":"Golang 内存分配 - stack and heap","headline":"Golang 内存分配 - stack and heap","description":"https:\/\/golang.org\/doc\/faq#stack_or_heap stack and pointers 我不能解释地像 William Kennedy一样优秀，那就让我来做一个汇总. 一个变量可以被分配在 heap或是stack: The stack contains the ongoing variables for a given goroutine. Once a function","inLanguage":"zh-CN","author":"Colynn.Liu","creator":"Colynn.Liu","publisher":"Colynn.Liu","accountablePerson":"Colynn.Liu","copyrightHolder":"Colynn.Liu","copyrightYear":"2020","datePublished":"2020-04-29 00:00:00 \u002b0000 UTC","dateModified":"2020-04-29 00:00:00 \u002b0000 UTC","url":"https:\/\/colynn.github.io\/2020-07-16-go-memory-allocation\/","wordCount":"663","keywords":["go","stack","heap","Colynn.Liu"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/readings/>书单</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/readings/>书单</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">Golang 内存分配 - stack and heap</h1><div class=post-meta>Written by <a itemprop=name href=https://colynn.github.io/ rel=author>Colynn.Liu</a> with ♥
<span class=post-time>on <time datetime=2020-04-29 itemprop=datePublished>April 29, 2020</time></span>
<span class=post-time>- last modified on <time datetime=2020-04-29 itemprop=datePublished>June 15, 2020</time></span></div><div class=post-tags><section><span class=tag><a href=https://colynn.github.io/tags/go/><i class="iconfont icon-tag"></i>go</a></span>
<span class=tag><a href=https://colynn.github.io/tags/stack/><i class="iconfont icon-tag"></i>stack</a></span>
<span class=tag><a href=https://colynn.github.io/tags/heap/><i class="iconfont icon-tag"></i>heap</a></span></section><section></section></div></header><div class=post-content><h2 id=heading></h2><p><a href=https://golang.org/doc/faq#stack_or_heap>https://golang.org/doc/faq#stack_or_heap</a></p><h2 id=stack-and-pointers>stack and pointers</h2><p>我不能解释地像 <a href=https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html>William Kennedy</a>一样优秀，那就让我来做一个汇总.</p><p>一个变量可以被分配在 <code>heap</code>或是<code>stack</code>:</p><ol><li>The stack contains the <strong>ongoing</strong> variables for a given goroutine. Once a function returned, the variables are popped from the stack.</li><li>The heap contains the shared variables (global variables, etc.), and anything on the heap is maaged by the Garbage Collector.</li></ol><p>简而言之，当你需要<code>Sharing</code>变量，可以使用指针；</p><ul><li>如果你需要（<code>passing pointers</code> or <code>passing referencs</code>） (<strong>sharing down</strong>)，变量定义通常在 <code>stack</code> 内</li><li>如果你需要（<code>returning pointers</code> or <code>returning references</code>）(<strong>sharing up</strong>)，变量定义通常在 <code>heap</code> 内</li></ul><p><em>注</em>: 指针变量像其他的变量一样并不特殊，它们有一个内存分配而且它们保存一个值, 不论值的类型它们均可以指向，通常也占用相同的内存大小。</p><p><em>注</em>: The stack is important because it provides the physical memory space for the frame boundaries that are given to each individual function.</p><p><em>注</em>: All stack memory <strong>below</strong> the active frame is invalid but memory from the active frame and above is valid.</p><p><em>注</em>: It’s during each function call, when the frame is taken, that the stack memory for that frame is wiped clean.</p><p><em>注</em>: Making a function call means the goroutine needs to frame <strong>a new section of memory</strong> on the stack.</p><h2 id=from-the-faq>From the FAQ</h2><p><a href=https://golang.org/doc/faq#stack_or_heap>https://golang.org/doc/faq#stack_or_heap</a></p><p>When possible, the Go compilers will allocate variables that are local to a function in that function&rsquo;s stack frame.</p><p>However, if the compiler <strong>cannot prove</strong> that the variable is <strong>not referenced after the function returns</strong>, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors.</p><h2 id=结论>结论</h2><ol><li><p>Pointers serve <strong>one purpose</strong>, to <strong>share a value with a function</strong> so the function can read and write to that value even though the value does not exist directly inside its own frame.</p></li><li><p>Each semantic comes with a benefit and cost. <strong>Value semantics</strong> keep values on the <strong>stack</strong> which reduces pressure on the <strong>GC</strong>. However, there are different copies of any given value that must be stored, tracked and maintained. <strong>Pointer semantics</strong> place values on the <strong>heap</strong> which can put pressure on the <strong>GC</strong>. However, they are efficient because there is only one value that needs to be stored, tracked and maintained. The key is using each semantic correctly, consistently and in balance.</p></li></ol><h2 id=ask-the-compiler>Ask the compiler</h2><h3 id=compiler-flags>Compiler flags</h3><ul><li>go help build</li><li>go tool compile -h</li><li>go build -gcflags &ldquo;-m&rdquo;</li></ul><h2 id=when-are-values-construcated-on-the-heap>When are values construcated on the heap?</h2><ol><li><p>When a value could <strong>possibly</strong> be referenced <strong>after</strong> the function that constructed the value returns.</p></li><li><p>When the compiler determines a value is too large to fit on the stack.</p></li><li><p>When the compiler doesn&rsquo;t know the size of a value at compile time.</p></li></ol><h2 id=points-to-remember>Points to remember</h2><ul><li><p>Optimize for correctness, not performance.</p></li><li><p>Go only puts function variables on the stack if it can <strong>prove</strong> a variable is <strong>not used</strong> after the function returns.</p></li><li><p>Sharing down typically stays on the stack.</p></li><li><p>Sharing up typically escapes to the heap.</p></li><li><p>Ask the compiler to find out.</p></li><li><p>Don&rsquo;t guess. Use the tooling.</p></li></ul><h2 id=参考>参考</h2><p><a href=https://golang.org/doc/faq#stack_or_heap>https://golang.org/doc/faq#stack_or_heap</a></p></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Colynn.Liu</span></p><p class=copyright-item><span>Link:</span>
<a href=https://colynn.github.io/2020-07-16-go-memory-allocation/>https://colynn.github.io/2020-07-16-go-memory-allocation/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://colynn.github.io/tags/go/>#go</a></span>
<span class=tag><a href=https://colynn.github.io/tags/stack/>#stack</a></span>
<span class=tag><a href=https://colynn.github.io/tags/heap/>#heap</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://colynn.github.io/>home</a></span></section></div><div class=post-nav><a href=https://colynn.github.io/2020-04-10-kubernetes-networking-flannel-calico/ class=prev rel=prev title=kubernetes-网络组件-flannel-calico><i class="iconfont icon-left"></i>&nbsp;kubernetes-网络组件-flannel-calico</a>
<a href=https://colynn.github.io/2020-05-06-slice-internal/ class=next rel=next title="Go Slice 内部发生了什么">Go Slice 内部发生了什么&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script>const gitalk=new Gitalk({clientID:'7196948b9a586a342072',clientSecret:"1acf6a13bc1ce7b8d8e3554789781ba2aaa4575c",repo:"blog-comments",owner:"colynn",admin:"colynn",id:"/2020-07-16-go-memory-allocation/",distractionFreeMode:false,perPage:100});gitalk.render('gitalk-container')</script></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2018 - 2024</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://colynn.github.io/>Colynn.Liu</a> |</span>
<span><a href=https://colynn.github.io/friends>友情链接</a></span></div></footer><script src=/js/vendor_no_gallery.min.js async></script></div></body></html>