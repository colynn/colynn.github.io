<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Colynn.Liu"><meta name=description content="Full-Stack DevOps, Be focused and Practical"><link rel=prev href=https://colynn.github.io/2019-03-05-mac_prepare_php_env/><link rel=next href=https://colynn.github.io/2019-07-26-basic_knowledge_summarizing/><link rel=canonical href=https://colynn.github.io/2019-12-31-go_basic_knowledge_summarizing/><link rel=apple-touch-icon sizes=180x180 href=/img/home-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Go 语法汇总 | Colynn.Liu</title><meta name=title content="Go 语法汇总 | Colynn.Liu"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/colynn.github.io\/"},"articleSection":"posts","name":"Go 语法汇总","headline":"Go 语法汇总","description":"变量声明 指定变量类型，如果没有初始化，则变量默认为零值; package main import \u0026#34;fmt\u0026#34; func main() { \/\/ 声明一个变量并初始化 var a = \u0026#34;RUNOOB\u0026#34; fmt.Println(a) \/\/ 没有初始化就为零值 var b int fmt.Println(b) \/\/ bool 零值为","inLanguage":"zh-CN","author":"Colynn.Liu","creator":"Colynn.Liu","publisher":"Colynn.Liu","accountablePerson":"Colynn.Liu","copyrightHolder":"Colynn.Liu","copyrightYear":"2019","datePublished":"2019-03-15 00:00:00 \u002b0000 UTC","dateModified":"2019-03-15 00:00:00 \u002b0000 UTC","url":"https:\/\/colynn.github.io\/2019-12-31-go_basic_knowledge_summarizing\/","wordCount":"5457","keywords":["go","Colynn.Liu"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/readings/>书单</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=https://colynn.github.io/>Colynn.Liu</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>文章</a>
<a class=menu-item href=/categories/>分类</a>
<a class=menu-item href=/tags/>标签</a>
<a class=menu-item href=/readings/>书单</a>
<a class=menu-item href=/aboutme/>关于我</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">Go 语法汇总</h1><div class=post-meta>Written by <a itemprop=name href=https://colynn.github.io/ rel=author>Colynn.Liu</a> with ♥
<span class=post-time>on <time datetime=2019-03-15 itemprop=datePublished>March 15, 2019</time></span>
<span class=post-time>- last modified on <time datetime=2019-03-15 itemprop=datePublished>March 15, 2019</time></span></div><div class=post-tags><section><span class=tag><a href=https://colynn.github.io/tags/go/><i class="iconfont icon-tag"></i>go</a></span></section><section><i class="iconfont icon-folder"></i><span class=post-category><a href=https://colynn.github.io/categories/%E5%9F%BA%E7%A1%80%E6%89%8B%E5%86%8C/>基础手册</a></span></section></div></header><div class=post-content><h2 id=变量声明>变量声明</h2><ol><li><p>指定变量类型，如果没有初始化，则变量默认为零值;</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main
<span style=color:#080;font-weight:700>import</span> <span style=background-color:#fff0f0>&#34;fmt&#34;</span>
<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {

    <span style=color:#888>// 声明一个变量并初始化
</span><span style=color:#888></span>    <span style=color:#080;font-weight:700>var</span> a = <span style=background-color:#fff0f0>&#34;RUNOOB&#34;</span>
    fmt.<span style=color:#06b;font-weight:700>Println</span>(a)

    <span style=color:#888>// 没有初始化就为零值
</span><span style=color:#888></span>    <span style=color:#080;font-weight:700>var</span> b <span style=color:#339;font-weight:700>int</span>
    fmt.<span style=color:#06b;font-weight:700>Println</span>(b)

    <span style=color:#888>// bool 零值为 false
</span><span style=color:#888></span>    <span style=color:#080;font-weight:700>var</span> c <span style=color:#339;font-weight:700>bool</span>
    fmt.<span style=color:#06b;font-weight:700>Println</span>(c)
}
</code></pre></div></li><li><p>根据值自行判定变量类型</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>var</span> v_name = value
</code></pre></div></li><li><p>省略 var, 注意 := 左侧如果没有声明新的变量，就产生编译错误</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>var</span> intVal <span style=color:#339;font-weight:700>int</span> 

intVal <span style=color:#333>:=</span><span style=color:#00d;font-weight:700>1</span> <span style=color:#888>// 这时候会产生编译错误
</span><span style=color:#888></span>
intVal,intVal1 <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>1</span>,<span style=color:#00d;font-weight:700>2</span> <span style=color:#888>// 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句
</span></code></pre></div></li></ol><h2 id=多变量声明>多变量声明</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>var</span> x, y <span style=color:#339;font-weight:700>int</span>
<span style=color:#080;font-weight:700>var</span> (  <span style=color:#888>// 这种因式分解关键字的写法一般用于声明全局变量
</span><span style=color:#888></span>    a <span style=color:#339;font-weight:700>int</span>
    b <span style=color:#339;font-weight:700>bool</span>
)

<span style=color:#080;font-weight:700>var</span> c, d <span style=color:#339;font-weight:700>int</span> = <span style=color:#00d;font-weight:700>1</span>, <span style=color:#00d;font-weight:700>2</span>
<span style=color:#080;font-weight:700>var</span> e, f = <span style=color:#00d;font-weight:700>123</span>, <span style=background-color:#fff0f0>&#34;hello&#34;</span>

<span style=color:#888>// 短声明方式
</span><span style=color:#888>// 这种不带声明格式的只能在函数体中出现
</span><span style=color:#888>// g, h := 123, &#34;hello&#34;
</span><span style=color:#888></span>
<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>(){
    g, h <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>123</span>, <span style=background-color:#fff0f0>&#34;hello&#34;</span>
    <span style=color:#007020>println</span>(x, y, a, b, c, d, e, f, g, h)
}
</code></pre></div><p><em>注</em>:</p><ol><li>类型在变量名 之后。</li><li>当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。</li><li>var 语句可以出现在包或函数级别。</li><li>变量声明可以包含初始值，每个变量对应一个; 初始化值已存在，则可以省略类型；变量会从初始值中获得类型。</li><li>常量可以是字符、字符串、布尔值或数值, 常量不能用 := 语法声明。</li></ol><h2 id=零值>零值</h2><p>没有明确初始值的变量声明会被赋予它们的 零值。</p><p>零值是：</p><ul><li>数值类型为 0，</li><li>布尔类型为 false，</li><li>字符串为 &ldquo;"（空字符串）</li></ul><h2 id=go-的基本类型有>Go 的基本类型有</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#339;font-weight:700>bool</span>

<span style=color:#339;font-weight:700>string</span>

<span style=color:#339;font-weight:700>int</span>  <span style=color:#339;font-weight:700>int8</span>  <span style=color:#339;font-weight:700>int16</span>  <span style=color:#339;font-weight:700>int32</span>  <span style=color:#339;font-weight:700>int64</span>
<span style=color:#339;font-weight:700>uint</span> <span style=color:#339;font-weight:700>uint8</span> <span style=color:#339;font-weight:700>uint16</span> <span style=color:#339;font-weight:700>uint32</span> <span style=color:#339;font-weight:700>uint64</span> <span style=color:#339;font-weight:700>uintptr</span>

<span style=color:#339;font-weight:700>byte</span> <span style=color:#888>// uint8 的别名
</span><span style=color:#888></span>
<span style=color:#339;font-weight:700>rune</span> <span style=color:#888>// int32 的别名
</span><span style=color:#888></span>    <span style=color:#888>// 表示一个 Unicode 码点
</span><span style=color:#888></span>
<span style=color:#339;font-weight:700>float32</span> <span style=color:#339;font-weight:700>float64</span>

<span style=color:#339;font-weight:700>complex64</span> <span style=color:#339;font-weight:700>complex128</span>
</code></pre></div><p>本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> (
	<span style=background-color:#fff0f0>&#34;fmt&#34;</span>
	<span style=background-color:#fff0f0>&#34;math/cmplx&#34;</span>
)

<span style=color:#080;font-weight:700>var</span> (
	ToBe   <span style=color:#339;font-weight:700>bool</span>       = <span style=color:#080;font-weight:700>false</span>
	MaxInt <span style=color:#339;font-weight:700>uint64</span>     = <span style=color:#00d;font-weight:700>1</span><span style=color:#333>&lt;&lt;</span><span style=color:#00d;font-weight:700>64</span> <span style=color:#333>-</span> <span style=color:#00d;font-weight:700>1</span>
	z      <span style=color:#339;font-weight:700>complex128</span> = cmplx.<span style=color:#06b;font-weight:700>Sqrt</span>(<span style=color:#333>-</span><span style=color:#00d;font-weight:700>5</span> <span style=color:#333>+</span> <span style=color:#60e;font-weight:700>12i</span>)
)

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	fmt.<span style=color:#06b;font-weight:700>Printf</span>(<span style=background-color:#fff0f0>&#34;Type: %T Value: %v\n&#34;</span>, ToBe, ToBe)
	fmt.<span style=color:#06b;font-weight:700>Printf</span>(<span style=background-color:#fff0f0>&#34;Type: %T Value: %v\n&#34;</span>, MaxInt, MaxInt)
	fmt.<span style=color:#06b;font-weight:700>Printf</span>(<span style=background-color:#fff0f0>&#34;Type: %T Value: %v\n&#34;</span>, z, z)
}
</code></pre></div><p><em>注</em>:</p><ul><li>int, uint 和 uintptr 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 int 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</li><li>reflect.TypeOf(x) 打印x的类型</li><li>常用的格式化字符串：</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>%v the value in a default format, when printing structs, the plus flag (%+v) adds field names 

%#v a Go-syntax representation of the value 
%T a Go-syntax representation of the type of the value
%%	a literal percent sign; consumes no value

</code></pre></div><ul><li>Boolean:</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>%t	the word true or false
</code></pre></div><ul><li>Integer:</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>%b	base 2
%c	the character represented by the corresponding Unicode code point
%d	base 10
%o	base 8
%O	base 8 with 0o prefix
%q	a single-quoted character literal safely escaped with Go syntax.
%x	base 16, with lower-case letters for a-f
%X	base 16, with upper-case letters for A-F
%U	Unicode format: U+1234; same as &#34;U+%04X&#34;
</code></pre></div><h2 id=--操作符>&#187; &#171; 操作符</h2><p>In decimal, 8 &#187; 1 is 4, and 8 &#171; 1 is 16. Shifting left by one is the same as multiplication by 2, and shifting right by one is the same as dividing by two, discarding any remainder.</p><p>It makes a lot of sense when I think that I was seeing this in code dealing with powers of 2 (1 &#171; power = 2^power)</p><p>等价于这样： (x &#171; n == x<em>2^n ) (x &#187; n == x</em>2^(-n))</p><h2 id=for循环>For循环</h2><p>Go 只有一种循环结构：for 循环。</p><ul><li>基本的 for 循环由三部分组成，它们用分号隔开：</li></ul><p>初始化语句：在第一次迭代前执行
条件表达式：在每次迭代前求值
后置语句：在每次迭代的结尾执行
初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。</p><p>一旦条件表达式的布尔值为 false，循环迭代就会终止。</p><p>注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 { } 则是必须的。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> <span style=background-color:#fff0f0>&#34;fmt&#34;</span>

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	sum <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>0</span>
	<span style=color:#080;font-weight:700>for</span> i <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>0</span>; i &lt; <span style=color:#00d;font-weight:700>10</span>; i<span style=color:#333>++</span> {
		sum <span style=color:#333>+=</span> i
	}
	fmt.<span style=color:#06b;font-weight:700>Println</span>(sum)
}

</code></pre></div><ul><li>初始化语句和后置语句是可选的。</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> <span style=background-color:#fff0f0>&#34;fmt&#34;</span>

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	sum <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>1</span>
	<span style=color:#080;font-weight:700>for</span> ; sum &lt; <span style=color:#00d;font-weight:700>1000</span>; {
		sum <span style=color:#333>+=</span> sum
	}
	fmt.<span style=color:#06b;font-weight:700>Println</span>(sum)
}
</code></pre></div><ul><li>此时你可以去掉分号，因为 C 的 while 在 Go 中叫做 for。</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> <span style=background-color:#fff0f0>&#34;fmt&#34;</span>

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	sum <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>1</span>
	<span style=color:#080;font-weight:700>for</span> sum &lt; <span style=color:#00d;font-weight:700>1000</span> {
		sum <span style=color:#333>+=</span> sum
	}
	fmt.<span style=color:#06b;font-weight:700>Println</span>(sum)
}
</code></pre></div><ul><li>for 循环的 range 形式可遍历切片或映射。</li></ul><p>可以将下标或值赋予 _ 来忽略它。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>for</span> i, _ <span style=color:#333>:=</span> <span style=color:#080;font-weight:700>range</span> pow
<span style=color:#080;font-weight:700>for</span> _, value <span style=color:#333>:=</span> <span style=color:#080;font-weight:700>range</span> pow
</code></pre></div><p>若你只需要索引，忽略第二个变量即可。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>for</span> i <span style=color:#333>:=</span> <span style=color:#080;font-weight:700>range</span> pow
</code></pre></div><p>代码示例</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> <span style=background-color:#fff0f0>&#34;fmt&#34;</span>

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	pow <span style=color:#333>:=</span> <span style=color:#007020>make</span>([]<span style=color:#339;font-weight:700>int</span>, <span style=color:#00d;font-weight:700>10</span>)
	<span style=color:#080;font-weight:700>for</span> i <span style=color:#333>:=</span> <span style=color:#080;font-weight:700>range</span> pow {
		pow[i] = <span style=color:#00d;font-weight:700>1</span> <span style=color:#333>&lt;&lt;</span> <span style=color:#007020>uint</span>(i) <span style=color:#888>// == 2**i
</span><span style=color:#888></span>	}
	<span style=color:#080;font-weight:700>for</span> i, value <span style=color:#333>:=</span> <span style=color:#080;font-weight:700>range</span> pow {
		fmt.<span style=color:#06b;font-weight:700>Printf</span>(<span style=background-color:#fff0f0>&#34;%v\t%d\n&#34;</span>, i, value)
	}
}
</code></pre></div><h2 id=defer>defer</h2><p>defer 语句会将函数推迟到外层函数返回之后执行。</p><ul><li>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> <span style=background-color:#fff0f0>&#34;fmt&#34;</span>

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	<span style=color:#080;font-weight:700>defer</span> fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;world&#34;</span>)

	fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;hello&#34;</span>)
}

</code></pre></div><ul><li>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> <span style=background-color:#fff0f0>&#34;fmt&#34;</span>

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;counting&#34;</span>)

	<span style=color:#080;font-weight:700>for</span> i <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>0</span>; i &lt; <span style=color:#00d;font-weight:700>10</span>; i<span style=color:#333>++</span> {
		<span style=color:#080;font-weight:700>defer</span> fmt.<span style=color:#06b;font-weight:700>Println</span>(i)
	}

	fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;done&#34;</span>)
}

</code></pre></div><h2 id=指针>指针</h2><p>Go 拥有指针。指针保存了值的内存地址。</p><p>类型 *T 是指向 T 类型值的指针。其零值为 nil。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>var</span> p <span style=color:#333>*</span><span style=color:#339;font-weight:700>int</span>
</code></pre></div><p>& 操作符会生成一个指向其操作数的指针。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>i <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>42</span>
p = <span style=color:#333>&amp;</span>i
</code></pre></div><ul><li>操作符表示指针指向的底层值。</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=color:#333>*</span>p) <span style=color:#888>// 通过指针 p 读取 i
</span><span style=color:#888></span><span style=color:#333>*</span>p = <span style=color:#00d;font-weight:700>21</span>         <span style=color:#888>// 通过指针 p 设置 i
</span></code></pre></div><p>这也就是通常所说的“间接引用”或“重定向”。</p><p>与 C 不同，Go 没有指针运算。</p><h2 id=结构体指针>结构体指针</h2><p>结构体字段可以通过结构体指针来访问。</p><p>如果我们有一个指向结构体的指针 p，那么可以通过 (*p).X 来访问其字段 X。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> <span style=background-color:#fff0f0>&#34;fmt&#34;</span>

<span style=color:#080;font-weight:700>type</span> Vertex <span style=color:#080;font-weight:700>struct</span> {
	X <span style=color:#339;font-weight:700>int</span>
	Y <span style=color:#339;font-weight:700>int</span>
}

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	v <span style=color:#333>:=</span> Vertex{<span style=color:#00d;font-weight:700>1</span>, <span style=color:#00d;font-weight:700>2</span>}
	p <span style=color:#333>:=</span> <span style=color:#333>&amp;</span><span style=color:#06b;font-weight:700>v</span>
	(<span style=color:#333>*</span>p).Y = <span style=color:#00d;font-weight:700>19</span>
	p.X = <span style=color:#60e;font-weight:700>1e9</span>
	fmt.<span style=color:#06b;font-weight:700>Println</span>(v)
}
</code></pre></div><h2 id=结构体文法>结构体文法</h2><p>结构体文法通过直接列出字段的值来新分配一个结构体。</p><p>使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）</p><p>特殊的前缀 & 返回一个指向结构体的指针。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> <span style=background-color:#fff0f0>&#34;fmt&#34;</span>

<span style=color:#080;font-weight:700>type</span> Vertex <span style=color:#080;font-weight:700>struct</span> {
	X, Y <span style=color:#339;font-weight:700>int</span>
}

<span style=color:#080;font-weight:700>var</span> (
	v1 = Vertex{<span style=color:#00d;font-weight:700>1</span>, <span style=color:#00d;font-weight:700>2</span>}  <span style=color:#888>// 创建一个 Vertex 类型的结构体
</span><span style=color:#888></span>
    <span style=color:#888>// ?? 这种就是结构体文法吗？
</span><span style=color:#888></span>	v2 = Vertex{X: <span style=color:#00d;font-weight:700>1</span>}  <span style=color:#888>// Y:0 被隐式地赋予
</span><span style=color:#888></span>	v3 = Vertex{}      <span style=color:#888>// X:0 Y:0
</span><span style=color:#888></span>	p  = <span style=color:#333>&amp;</span>Vertex{<span style=color:#00d;font-weight:700>1</span>, <span style=color:#00d;font-weight:700>2</span>} <span style=color:#888>// 创建一个 *Vertex 类型的结构体（指针）
</span><span style=color:#888></span>)

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	fmt.<span style=color:#06b;font-weight:700>Println</span>(v1, p.X, v2, v3)
}
</code></pre></div><h2 id=数组>数组</h2><p>类型 [n]T 表示拥有 n 个 T 类型的值的数组。</p><p>表达式</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>var</span> a [<span style=color:#00d;font-weight:700>10</span>]<span style=color:#339;font-weight:700>int</span>
</code></pre></div><p>会将变量 a 声明为拥有 10 个整数的数组。</p><p>数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> <span style=background-color:#fff0f0>&#34;fmt&#34;</span>

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	<span style=color:#080;font-weight:700>var</span> a [<span style=color:#00d;font-weight:700>2</span>]<span style=color:#339;font-weight:700>string</span>
	a[<span style=color:#00d;font-weight:700>0</span>] = <span style=background-color:#fff0f0>&#34;Hello&#34;</span>
	a[<span style=color:#00d;font-weight:700>1</span>] = <span style=background-color:#fff0f0>&#34;World&#34;</span>
	fmt.<span style=color:#06b;font-weight:700>Println</span>(a[<span style=color:#00d;font-weight:700>0</span>], a[<span style=color:#00d;font-weight:700>1</span>])
	fmt.<span style=color:#06b;font-weight:700>Println</span>(a)

    <span style=color:#888>// ?? 不理解为何种用法
</span><span style=color:#888></span>	primes <span style=color:#333>:=</span> [<span style=color:#00d;font-weight:700>6</span>]<span style=color:#339;font-weight:700>int</span>{<span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>, <span style=color:#00d;font-weight:700>5</span>, <span style=color:#00d;font-weight:700>7</span>, <span style=color:#00d;font-weight:700>11</span>, <span style=color:#00d;font-weight:700>13</span>}  
	fmt.<span style=color:#06b;font-weight:700>Println</span>(primes)
}
</code></pre></div><h2 id=切片>切片</h2><p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p><p>类型 []T 表示一个元素类型为 T 的切片。</p><p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>a[low : high]
</code></pre></div><p>它会选择一个半开区间，包括第一个元素，但排除最后一个元素。</p><p>以下表达式创建了一个切片，它包含 a 中下标从 1 到 3 的元素：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>a[<span style=color:#00d;font-weight:700>1</span>:<span style=color:#00d;font-weight:700>4</span>]
</code></pre></div><ul><li>切片的默认行为</li></ul><p>对于数组</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>var</span> a [<span style=color:#00d;font-weight:700>10</span>]<span style=color:#339;font-weight:700>int</span>
</code></pre></div><p>来说，以下切片是等价的：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>a[<span style=color:#00d;font-weight:700>0</span>:<span style=color:#00d;font-weight:700>10</span>]
a[:<span style=color:#00d;font-weight:700>10</span>]
a[<span style=color:#00d;font-weight:700>0</span>:]
a[:]
</code></pre></div><p><em>注</em>:</p><ul><li><p>切片就像数组的引用</p></li><li><p>切片并不存储任何数据，它只是描述了底层数组中的一段。</p></li><li><p>更改切片的元素会修改其底层数组中对应的元素。</p></li><li><p>与它共享底层数组的切片都会观测到这些修改。</p></li><li><p>切片s的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。</p></li><li><p>切片的零值是 nil.</p></li><li><p>切片练习??：</p></li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>实现 Pic。它应当返回一个长度为 dy 的切片，其中每个元素是一个长度为 dx，元素类型为 uint8 的切片。当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像。

图像的选择由你来定。几个有趣的函数包括 <span style=color:#333>(</span>x+y<span style=color:#333>)</span>/2, x*y, x^y, x*log<span style=color:#333>(</span>y<span style=color:#333>)</span> 和 x%<span style=color:#333>(</span>y+1<span style=color:#333>)</span>。

（提示：需要使用循环来分配 <span style=color:#333>[][]</span>uint8 中的每个 <span style=color:#333>[]</span>uint8；请使用 uint8<span style=color:#333>(</span>intValue<span style=color:#333>)</span> 在类型之间转换；你可能会用到 math 包中的函数。）
</code></pre></div><h2 id=函数值>函数值</h2><p>函数也是值。它们可以像其它值一样传递。</p><p>函数值可以用作函数的参数或返回值。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> (
	<span style=background-color:#fff0f0>&#34;fmt&#34;</span>
	<span style=background-color:#fff0f0>&#34;math&#34;</span>
	<span style=background-color:#fff0f0>&#34;reflect&#34;</span>
)

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>compute</span>(fn <span style=color:#080;font-weight:700>func</span>(<span style=color:#339;font-weight:700>float64</span>, <span style=color:#339;font-weight:700>float64</span>) <span style=color:#339;font-weight:700>float64</span>) <span style=color:#339;font-weight:700>float64</span> {
	<span style=color:#080;font-weight:700>return</span> <span style=color:#06b;font-weight:700>fn</span>(<span style=color:#00d;font-weight:700>3</span>, <span style=color:#00d;font-weight:700>4</span>)
}

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	hypot <span style=color:#333>:=</span> <span style=color:#080;font-weight:700>func</span>(x, y <span style=color:#339;font-weight:700>float64</span>) <span style=color:#339;font-weight:700>float64</span> {
		<span style=color:#080;font-weight:700>return</span> math.<span style=color:#06b;font-weight:700>Sqrt</span>(x<span style=color:#333>*</span>x <span style=color:#333>+</span> y<span style=color:#333>*</span>y)
	}
	fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=color:#06b;font-weight:700>hypot</span>(<span style=color:#00d;font-weight:700>5</span>, <span style=color:#00d;font-weight:700>12</span>))
	
	fmt.<span style=color:#06b;font-weight:700>Println</span>(reflect.<span style=color:#06b;font-weight:700>TypeOf</span>(hypot))
	
	fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=color:#06b;font-weight:700>compute</span>(hypot))
	fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=color:#06b;font-weight:700>compute</span>(math.Pow))
}
</code></pre></div><p>输出：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#60e;font-weight:700>13</span>
func<span style=color:#333>(</span>float64, float64<span style=color:#333>)</span> float64
<span style=color:#60e;font-weight:700>5</span>
<span style=color:#60e;font-weight:700>81</span>
</code></pre></div><h2 id=接口>接口</h2><p>接口类型 是由一组方法签名定义的集合。</p><p>接口类型的变量可以保存任何实现了这些方法的值。</p><h3 id=compile-time-checks>Compile time checks</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#888>// Notify ..
</span><span style=color:#888></span><span style=color:#080;font-weight:700>type</span> Notify <span style=color:#080;font-weight:700>interface</span> {
	<span style=color:#06b;font-weight:700>Send</span>() <span style=color:#339;font-weight:700>string</span>
}

<span style=color:#888>// Email ..
</span><span style=color:#888></span><span style=color:#080;font-weight:700>type</span> email <span style=color:#080;font-weight:700>struct</span>{}

<span style=color:#080;font-weight:700>var</span> _ Notify = (<span style=color:#333>*</span>email)(<span style=color:#080;font-weight:700>nil</span>)

<span style=color:#888>// Send ..
</span><span style=color:#888></span><span style=color:#080;font-weight:700>func</span> (e <span style=color:#333>*</span>email) <span style=color:#06b;font-weight:700>Send</span>() <span style=color:#339;font-weight:700>string</span> {
	<span style=color:#080;font-weight:700>return</span> <span style=background-color:#fff0f0>&#34;&#34;</span>
}
</code></pre></div><p>注解：</p><ul><li><p><code>var _ Notify = (*email)(nil)</code> It provides a static (compile time) check that <code>email</code> satisfies the <code>Notify</code> interface.</p></li><li><p>The <code>_</code> used as a name of the variable tells the compiler to effectively discard the RHS value, but to type-check it and evaluate it if it has any side effects, but the anonymous variable per se doesn&rsquo;t take any process space.</p></li><li><p>If you forget a method or if the interface changes, you’ll get a compile-time error drawing your attention to it immediately:
cannot use (*email)(nil) (type *email) as type Notify in assignment:
*email does not implement Notify (missing SomeMethod method)</p></li><li><p><code>(*email)(nil)</code> Essentially you are casting <code>nil</code> to a type of pointer to <code>MyType</code>. It’s a zero-memory way to represent a pointer to your struct in Go.</p></li></ul><h2 id=空接口>空接口</h2><p>指定了零个方法的接口值被称为 <em>空接口：</em></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>interface</span>{}
</code></pre></div><p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p><p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface{}</code> 的任意数量的参数。</p><h2 id=类型断言>类型断言</h2><p>类型断言 提供了访问接口值底层具体值的方式。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>t <span style=color:#333>:=</span> i.(T)
</code></pre></div><p>该语句断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t。</p><p>若 i 并未保存 T 类型的值，该语句就会触发一个恐慌。</p><p>为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>t, ok <span style=color:#333>:=</span> i.(T)
</code></pre></div><ul><li>i 代码要判断的变量， 必须为interface类型才可以进行类型断言；</li><li>T 代表要被判断的类型，eg: string, int64, struct</li><li>t 代表返回的值，</li><li>ok 代码是否为该类型</li></ul><p>若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true。</p><p>否则，ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生恐慌。</p><p>请注意这种语法和读取一个映射时的相同之处。</p><p>示例代码</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>s <span style=color:#333>:=</span> <span style=background-color:#fff0f0>&#34;baidu&#34;</span>
<span style=color:#080;font-weight:700>if</span> v, ok <span style=color:#333>:=</span> s.(<span style=color:#339;font-weight:700>string</span>); ok {
	fmt.<span style=color:#06b;font-weight:700>Println</span>(v)
}
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>invalid <span style=color:#007020>type</span> assertion: s.<span style=color:#333>(</span>string<span style=color:#333>)</span> <span style=color:#333>(</span>non-interface <span style=color:#007020>type</span> string on left<span style=color:#333>)</span>
</code></pre></div><p>在这里只要是在声明时或函数传进来的参数不是interface类型那么做类型断言都是回报 non-interface的错误的</p><p>所以我们只能通过将s作为一个interface{}的方法来进行类型断言 如下代码所示</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>s <span style=color:#333>:=</span> <span style=background-color:#fff0f0>&#34;BrainWu&#34;</span>
<span style=color:#080;font-weight:700>if</span> v, ok <span style=color:#333>:=</span> <span style=color:#080;font-weight:700>interface</span>{}(s).(<span style=color:#339;font-weight:700>string</span>); ok {
	fmt.<span style=color:#06b;font-weight:700>Println</span>(v)
}
</code></pre></div><p>将s显示的转换为interface{}接口类型则可以进行类型断言了</p><p>2 当函数作为参数并且被调用函数将参数类型指定为interface{}的时候是没有办法直接调用该方法的
比如如下代码是错误的在编译期间就会报错
<code>cannot convert in (type interface {}) to type Handler: need type assertion</code></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>ServeHTTP</span>(s <span style=color:#339;font-weight:700>string</span>) {
	fmt.<span style=color:#06b;font-weight:700>Println</span>(s)
}

<span style=color:#080;font-weight:700>type</span> Handler <span style=color:#080;font-weight:700>func</span>(<span style=color:#339;font-weight:700>string</span>)

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>panduan</span>(in <span style=color:#080;font-weight:700>interface</span>{}) {
	<span style=color:#06b;font-weight:700>Handler</span>(in)(<span style=background-color:#fff0f0>&#34;wujunbin&#34;</span>)
}

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	<span style=color:#06b;font-weight:700>panduan</span>(<span style=color:#06b;font-weight:700>Handler</span>(ServeHTTP))
}
</code></pre></div><p>根据错误提示是说要我们先进行类型断言才可以继续使用该类型的函数</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>if</span> v, ok <span style=color:#333>:=</span> in.(Handler); ok {
	<span style=color:#888>//跟什么类型判断就只能调用什么类型的方法
</span><span style=color:#888></span>	<span style=color:#06b;font-weight:700>v</span>(<span style=background-color:#fff0f0>&#34;BrainWu&#34;</span>)
}
</code></pre></div><p>只有让传进来的in参数先与Handler进行类型判断 如果返回值是OK则代表类型相同才能进行对应的方法调用</p><p>另外进行类型断言之后如果断言成功 就只能使用该类型的方法比如对一个结构体S进行与A接口断言</p><p>S实际上实现了A B两个接口 // 待进一步理解？？</p><p>A interface 具有 a()方法  B interface 具有 b()方法 如果结构体S作为参数被传入一个函数中并且在该函数中是interface{}类型</p><p>那么进行与A的类型断言之后就只能调用a()而不能调用b()因为编译器只知道你目前是A类型却不知道你目前也是B类型。</p><p>3 另外讲解 switch与类型断言的结合使用还是比较方便的, 比如下面这个例子</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> (
	<span style=background-color:#fff0f0>&#34;fmt&#34;</span>
)

<span style=color:#080;font-weight:700>type</span> Element <span style=color:#080;font-weight:700>interface</span> {}

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	<span style=color:#080;font-weight:700>var</span> e Element = <span style=color:#00d;font-weight:700>100</span>
	<span style=color:#080;font-weight:700>switch</span> value <span style=color:#333>:=</span> e.(<span style=color:#080;font-weight:700>type</span>) {
	<span style=color:#080;font-weight:700>case</span> <span style=color:#339;font-weight:700>int</span>:
		fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;int&#34;</span>, value)
	<span style=color:#080;font-weight:700>case</span> <span style=color:#339;font-weight:700>string</span>:
		fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;string&#34;</span>, value)
	<span style=color:#080;font-weight:700>default</span>:
		fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;unknown&#34;</span>, value)
	}
}
</code></pre></div><p>打印结果：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>int <span style=color:#60e;font-weight:700>100</span>
</code></pre></div><ul><li>参考链接： <a href=https://blog.csdn.net/cbmljs/article/details/82966907>https://blog.csdn.net/cbmljs/article/details/82966907</a></li></ul><p><strong>注</strong>:</p><ul><li>类型选择中的声明与类型断言 i.(T) 的语法相同，只是具体类型 T 被替换成了关键字 type。</li></ul><h2 id=stringer>Stringer</h2><h2 id=reader>Reader</h2><h2 id=goroutines和channels>Goroutines和Channels</h2><ol><li>如果我们使用了无缓存的channel, 那么两个慢的goroutines将会因为没有人接收而永远卡住。这种情况，称为goroutines泄漏，这将是一个BUG.和垃圾变量不同，泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。</li></ol><h2 id=labels-in-go>Labels in Go</h2><h3 id=goto><code>goto</code></h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
    fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=color:#00d;font-weight:700>1</span>)
    <span style=color:#080;font-weight:700>goto</span> End
    fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=color:#00d;font-weight:700>2</span>)
End:
    fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=color:#00d;font-weight:700>3</span>)
}
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>&gt; ./bin/sandbox
<span style=color:#60e;font-weight:700>1</span>
<span style=color:#60e;font-weight:700>3</span>
</code></pre></div><p>Labels are not block scoped (more about blocks and scoping in “Blocks in Go” and “Scopes in Go”) so it’s impossible to redeclare label inside nested block:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>    <span style=color:#080;font-weight:700>goto</span> X
X:
    {
    X:
    }
</code></pre></div><p>as Go compiler will complain about already declared label.</p><p><strong>注</strong>: goto cannot move into other block</p><p>Identifiers of the labels live in a separate space so they don’t conflict with i.e. variables identifiers. The code below works just fine even that x is used for two things:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>    x <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>1</span>
    <span style=color:#080;font-weight:700>goto</span> x
x:
    fmt.<span style=color:#06b;font-weight:700>Println</span>(x)
</code></pre></div><h3 id=break><code>break</code></h3><p><code>break</code> statement is traditionally used to terminate innermost <code>for</code> or <code>switch</code> statement. In Go it’s also possible to end this way novel <code>select</code> statement.</p><p>People having experience with languages like <code>C</code> and derivates know that each case clause needs to have break as a last statement. Otherwise execution in transferred to the next case clause which is not what programmer wants most of the time.</p><p>Go however works conversely — there is a <code>fallthrough</code> statement to explicitly move to the next clause:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>switch</span> <span style=color:#00d;font-weight:700>1</span> {
<span style=color:#080;font-weight:700>case</span> <span style=color:#00d;font-weight:700>1</span>:
    fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=color:#00d;font-weight:700>1</span>)
<span style=color:#080;font-weight:700>case</span> <span style=color:#00d;font-weight:700>2</span>:
    fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=color:#00d;font-weight:700>2</span>)
}
&gt; .<span style=color:#333>/</span>bin<span style=color:#333>/</span>sandbox
<span style=color:#00d;font-weight:700>1</span>
<span style=color:#080;font-weight:700>switch</span> <span style=color:#00d;font-weight:700>1</span> {
<span style=color:#080;font-weight:700>case</span> <span style=color:#00d;font-weight:700>1</span>:
    fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=color:#00d;font-weight:700>1</span>)
    <span style=color:#080;font-weight:700>fallthrough</span>
<span style=color:#080;font-weight:700>case</span> <span style=color:#00d;font-weight:700>2</span>:
    fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=color:#00d;font-weight:700>2</span>)
}
&gt; .<span style=color:#333>/</span>bin<span style=color:#333>/</span>sandbox
<span style=color:#00d;font-weight:700>1</span>
<span style=color:#00d;font-weight:700>2</span>
</code></pre></div><p>没带标签的<code>break</code>语句仅能终止最内层的<code>for</code>，<code>switch</code>或是 <code>select</code>， 添加了标签,<code>break</code>则提供了更多地可能性。</p><p>Label for <code>break</code> statement must be the one associated with enclosing <code>for</code>, <code>switch</code> or <code>select</code> statement.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>SwitchStatement:
    <span style=color:#080;font-weight:700>switch</span> <span style=color:#00d;font-weight:700>1</span> {
    <span style=color:#080;font-weight:700>case</span> <span style=color:#00d;font-weight:700>1</span>:
        fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=color:#00d;font-weight:700>1</span>)
        <span style=color:#080;font-weight:700>for</span> i <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>0</span>; i &lt; <span style=color:#00d;font-weight:700>10</span>; i<span style=color:#333>++</span> {
            <span style=color:#080;font-weight:700>break</span> SwitchStatement
        }
        fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=color:#00d;font-weight:700>2</span>)
    }
    fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=color:#00d;font-weight:700>3</span>)
&gt; .<span style=color:#333>/</span>bin<span style=color:#333>/</span>sandbox
<span style=color:#00d;font-weight:700>1</span>
<span style=color:#00d;font-weight:700>3</span>
</code></pre></div><p><strong>注</strong>: <code>break</code> statement cannot span over function boundaries</p><p><strong>注</strong>: It’s possible to terminate <code>for</code>, <code>switch</code> or <code>select</code> no matter where break statement is located.</p><h3 id=continue-statement><code>continue</code> statement</h3><p>It works in a similar way to <code>break</code> statement but begins next iteration instead of stopping and can be used only for loops:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>OuterLoop:
    <span style=color:#080;font-weight:700>for</span> i <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>0</span>; i &lt; <span style=color:#00d;font-weight:700>3</span>; i<span style=color:#333>++</span> {
        <span style=color:#080;font-weight:700>for</span> j <span style=color:#333>:=</span> <span style=color:#00d;font-weight:700>0</span>; j &lt; <span style=color:#00d;font-weight:700>3</span>; j<span style=color:#333>++</span> {
            fmt.<span style=color:#06b;font-weight:700>Printf</span>(<span style=color:red;background-color:#faa>“</span>i=<span style=color:#333>%</span>v, j=<span style=color:#333>%</span>v<span style=color:red;background-color:#faa>\</span>n<span style=color:red;background-color:#faa>”</span>, i, j)
            <span style=color:#080;font-weight:700>continue</span> OuterLoop
        }
    }
&gt; .<span style=color:#333>/</span>bin<span style=color:#333>/</span>sandbox
i=<span style=color:#00d;font-weight:700>0</span>, j=<span style=color:#00d;font-weight:700>0</span>
i=<span style=color:#00d;font-weight:700>1</span>, j=<span style=color:#00d;font-weight:700>0</span>
i=<span style=color:#00d;font-weight:700>2</span>, j=<span style=color:#00d;font-weight:700>0</span>
</code></pre></div><h2 id=疑问>疑问</h2><h3 id=1-结构体-函数定义-如下两种方式的不同点>1. 结构体 函数定义 如下两种方式的不同点</h3><h4 id=方式1>方式1</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>func</span> (t <span style=color:#333>*</span>T) <span style=color:#06b;font-weight:700>M</span>() {
	fmt.<span style=color:#06b;font-weight:700>Println</span>(t.S)
}

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	<span style=color:#080;font-weight:700>var</span> i I = T{<span style=background-color:#fff0f0>&#34;hello&#34;</span>}
	i.<span style=color:#06b;font-weight:700>M</span>()
}
</code></pre></div><h4 id=方式2>方式2</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>func</span> (t T) <span style=color:#06b;font-weight:700>M</span>() {
	fmt.<span style=color:#06b;font-weight:700>Println</span>(t.S)
}

<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	<span style=color:#080;font-weight:700>var</span> I = T{<span style=background-color:#fff0f0>&#34;hello&#34;</span>}
	I.<span style=color:#06b;font-weight:700>M</span>()
}
</code></pre></div><p><strong>注解</strong>:</p><ul><li><p>这两种方式均可以为结构体定义函数，方式1是为结构体指针对象
新增函数，方式2是为结构体对象新增函数。</p></li><li><p>场景不同，定义函数的方式也就不同，但是更推荐使用方式1，因为我们在声明、使用结构体变量多数也是作为指针变量使用的。</p></li></ul><h3 id=2-fmt-printprintlnprintfsprintf的区别>2. fmt Print/Println/Printf/Sprintf的区别</h3><pre><code>* `fmt.Print` 不会自动换行，也不能处理占位符。
* `fmt.Println` 会自动换行，但不能处理占位符。
* `fmt.Printf` 它通过 `os.Stdout` 输出格式化的字符串，可以处理占位符。
* `fmt.Sprintf` 则格式化并返回一个字符串而不带任何输出。
</code></pre><p>示例代码：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main

<span style=color:#080;font-weight:700>import</span> (<span style=background-color:#fff0f0>&#34;fmt&#34;</span>)
<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>() {
	<span style=color:#080;font-weight:700>var</span> test1 <span style=color:#339;font-weight:700>int</span> = <span style=color:#00d;font-weight:700>1</span>

	<span style=color:#080;font-weight:700>var</span> test2 <span style=color:#339;font-weight:700>int</span> = <span style=color:#00d;font-weight:700>2</span>

	fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;Println输出，不能处理占位符：%d&#34;</span>, test1)

	fmt.<span style=color:#06b;font-weight:700>Print</span>(<span style=background-color:#fff0f0>&#34;Print输出, 并没有换行&#34;</span>, test1)
	fmt.<span style=color:#06b;font-weight:700>Println</span>(<span style=background-color:#fff0f0>&#34;Println输出&#34;</span>, test1)


	fmt.<span style=color:#06b;font-weight:700>Printf</span>(<span style=background-color:#fff0f0>&#34;Printf输出，可以解析占位符：%d, 不会自动换行&#34;</span>, test1)

	fmt.<span style=color:#06b;font-weight:700>Printf</span>(<span style=background-color:#fff0f0>&#34;Printf输出,test1: %d, test2: %d&#34;</span>, test1, test2)
}

</code></pre></div><p>运行输出</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>Println输出，不能处理占位符：%d <span style=color:#60e;font-weight:700>1</span>
Print输出, 并没有换行1Println输出 <span style=color:#60e;font-weight:700>1</span>
Printf输出，可以解析占位符：1, 不会自动换行Printf输出,test1: 1, test2: <span style=color:#60e;font-weight:700>2123</span>
</code></pre></div><h3 id=3-字符串与数字转换>3. 字符串与数字转换</h3><h4 id=字符串转为int64>字符串转为int64</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>var</span> string1 = <span style=background-color:#fff0f0>&#34;123&#34;</span>
stringInt64, err <span style=color:#333>:=</span> strconv.<span style=color:#06b;font-weight:700>ParseInt</span>(string1, <span style=color:#00d;font-weight:700>10</span>, <span style=color:#00d;font-weight:700>64</span>)
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>var</span> a = <span style=background-color:#fff0f0>&#34;123&#34;</span>
<span style=color:#080;font-weight:700>if</span> b, <span style=color:#339;font-weight:700>error</span> <span style=color:#333>:=</span> strconv.<span style=color:#06b;font-weight:700>Atoi</span>(a); <span style=color:#339;font-weight:700>error</span> <span style=color:#333>==</span> <span style=color:#080;font-weight:700>nil</span> {
	fmt.<span style=color:#06b;font-weight:700>Printf</span>(<span style=background-color:#fff0f0>&#34;b: %T, %d&#34;</span>, b, b)
}
</code></pre></div><ul><li>数字拼接为字符串</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>d <span style=color:#333>:=</span> strconv.<span style=color:#06b;font-weight:700>Itoa</span>(<span style=color:#00d;font-weight:700>1234</span>)
fmt.<span style=color:#06b;font-weight:700>Printf</span>(<span style=background-color:#fff0f0>&#34;string: %s&#34;</span>, d)
</code></pre></div><ul><li>int 转换为二进制、十六进制</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>binary <span style=color:#333>:=</span> strconv.<span style=color:#06b;font-weight:700>FormatInt</span>(<span style=color:#007020>int64</span>(i), <span style=color:#00d;font-weight:700>2</span>)
hexadecimal <span style=color:#333>:=</span> strconv.<span style=color:#06b;font-weight:700>FormatInt</span>(<span style=color:#007020>int64</span>(i), <span style=color:#00d;font-weight:700>16</span>)
</code></pre></div><ul><li>字符串拼接</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>newString <span style=color:#333>:=</span> strings.<span style=color:#06b;font-weight:700>Join</span>([]<span style=color:#339;font-weight:700>string</span>{<span style=background-color:#fff0f0>&#34;string01&#34;</span>, <span style=background-color:#fff0f0>&#34;string02&#34;</span>}, <span style=background-color:#fff0f0>&#34;-&#34;</span>)
fmt.<span style=color:#06b;font-weight:700>Printf</span>(<span style=background-color:#fff0f0>&#34;newString: %s &#34;</span>, newString)
</code></pre></div><ul><li>字符串前、后缀</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#888>// 前缀
</span><span style=color:#888></span>strings.<span style=color:#06b;font-weight:700>HasPrefix</span>(s, prefix <span style=color:#339;font-weight:700>string</span>) <span style=color:#339;font-weight:700>bool</span>

<span style=color:#888>// 后缀
</span><span style=color:#888></span>strings.<span style=color:#06b;font-weight:700>HasSuffix</span>(s, suffix <span style=color:#339;font-weight:700>string</span>) <span style=color:#339;font-weight:700>bool</span>
</code></pre></div><ul><li>字符串包含</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>strings.<span style=color:#06b;font-weight:700>Contains</span>(s, substr <span style=color:#339;font-weight:700>string</span>) <span style=color:#339;font-weight:700>bool</span>
</code></pre></div><h3 id=4-数字操作>4. 数字操作</h3><h4 id=官方的math-包中提供了取整的方法向上取整mathceil-向下取整mathfloor>官方的math 包中提供了取整的方法，向上取整math.Ceil() ，向下取整math.Floor()</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>package</span> main
<span style=color:#080;font-weight:700>import</span> (
	<span style=background-color:#fff0f0>&#34;fmt&#34;</span>
	<span style=background-color:#fff0f0>&#34;math&#34;</span>
)
<span style=color:#080;font-weight:700>func</span> <span style=color:#06b;font-weight:700>main</span>(){
	x <span style=color:#333>:=</span> <span style=color:#60e;font-weight:700>1.1</span>
	fmt.<span style=color:#06b;font-weight:700>Println</span>(math.<span style=color:#06b;font-weight:700>Ceil</span>(x))  <span style=color:#888>// 2
</span><span style=color:#888></span>	fmt.<span style=color:#06b;font-weight:700>Println</span>(math.<span style=color:#06b;font-weight:700>Floor</span>(x))  <span style=color:#888>// 1
</span><span style=color:#888></span>}
</code></pre></div><h3 id=5-切片文法数组文法-使用场景时间复杂度>5. 切片文法、数组文法 使用场景，时间复杂度？</h3><h4 id=切片合并>切片合并</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	a <span style=color:#333>:=</span> []<span style=color:#339;font-weight:700>int</span>{<span style=color:#00d;font-weight:700>1</span>, <span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>}
	b <span style=color:#333>:=</span> []<span style=color:#339;font-weight:700>int</span>{<span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>, <span style=color:#00d;font-weight:700>4</span>, <span style=color:#00d;font-weight:700>5</span>, <span style=color:#00d;font-weight:700>6</span>}
	a = <span style=color:#007020>append</span>(a, b<span style=color:#333>...</span>)
</code></pre></div><h3 id=6-omitempty-在go中的使用>6. omitempty 在go中的使用</h3><p>示例：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-weight:700>type</span> Person <span style=color:#080;font-weight:700>struct</span> {
    Name <span style=color:#339;font-weight:700>string</span> <span style=background-color:#fff0f0>`json:&#34;name&#34;`</span>
    Age  <span style=color:#339;font-weight:700>int</span>    <span style=background-color:#fff0f0>`json:&#34;age&#34;`</span>
    Addr <span style=color:#339;font-weight:700>string</span> <span style=background-color:#fff0f0>`json:&#34;addr,omitempty&#34;`</span>
}
</code></pre></div><ul><li>有了omitempty后，如果addr为空， 则生成的json中没有addr字段。</li><li>如果没有定义 omitempty，则始终会返回addr这个字段。</li></ul><h3 id=refer-to>Refer to</h3><ol><li><a href=https://stackoverflow.com/questions/5801008/go-and-operators>Go &#171; and &#187; operators</a></li><li><a href=https://medium.com/golangspec/labels-in-go-4ffd81932339>Labels in Go</a></li></ol></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Colynn.Liu</span></p><p class=copyright-item><span>Link:</span>
<a href=https://colynn.github.io/2019-12-31-go_basic_knowledge_summarizing/>https://colynn.github.io/2019-12-31-go_basic_knowledge_summarizing/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://colynn.github.io/tags/go/>#go</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://colynn.github.io/>home</a></span></section></div><div class=post-nav><a href=https://colynn.github.io/2019-03-05-mac_prepare_php_env/ class=prev rel=prev title=Mac-PHP环境准备><i class="iconfont icon-left"></i>&nbsp;Mac-PHP环境准备</a>
<a href=https://colynn.github.io/2019-07-26-basic_knowledge_summarizing/ class=next rel=next title="python 语法汇总">python 语法汇总&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script>const gitalk=new Gitalk({clientID:'7196948b9a586a342072',clientSecret:"1acf6a13bc1ce7b8d8e3554789781ba2aaa4575c",repo:"blog-comments",owner:"colynn",admin:"colynn",id:"/2019-12-31-go_basic_knowledge_summarizing/",distractionFreeMode:false,perPage:100});gitalk.render('gitalk-container')</script></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2018 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://colynn.github.io/>Colynn.Liu</a> |</span>
<span><a href=https://colynn.github.io/friends>友情链接</a></span></div></footer><script src=/js/vendor_no_gallery.min.js async></script></div></body></html>